// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2* ImVec2Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*>)funcTable[0])();
			#else
			return (Vector2*)((delegate* unmanaged[Cdecl]<nint>)funcTable[0])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2* ImVec2()
		{
			Vector2* ret = ImVec2Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(Vector2* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[1])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(Vector2* self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref Vector2 self)
		{
			fixed (Vector2* pself = &self)
			{
				DestroyNative((Vector2*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2* ImVec2Native(float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, Vector2*>)funcTable[2])(x, y);
			#else
			return (Vector2*)((delegate* unmanaged[Cdecl]<float, float, nint>)funcTable[2])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2* ImVec2(float x, float y)
		{
			Vector2* ret = ImVec2Native(x, y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector4* ImVec4Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4*>)funcTable[3])();
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<nint>)funcTable[3])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4* ImVec4()
		{
			Vector4* ret = ImVec4Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(Vector4* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, void>)funcTable[4])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[4])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(Vector4* self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref Vector4 self)
		{
			fixed (Vector4* pself = &self)
			{
				DestroyNative((Vector4*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector4* ImVec4Native(float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, Vector4*>)funcTable[5])(x, y, z, w);
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<float, float, float, float, nint>)funcTable[5])(x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4* ImVec4(float x, float y, float z, float w)
		{
			Vector4* ret = ImVec4Native(x, y, z, w);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImTextureRef* ImTextureRefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImTextureRef*>)funcTable[6])();
			#else
			return (ImTextureRef*)((delegate* unmanaged[Cdecl]<nint>)funcTable[6])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImTextureRefPtr ImTextureRef()
		{
			ImTextureRefPtr ret = ImTextureRefNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImTextureRef* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImTextureRef*, void>)funcTable[7])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[7])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImTextureRefPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImTextureRef self)
		{
			fixed (ImTextureRef* pself = &self)
			{
				DestroyNative((ImTextureRef*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImTextureRef* ImTextureRefNative(ImTextureID texId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImTextureID, ImTextureRef*>)funcTable[8])(texId);
			#else
			return (ImTextureRef*)((delegate* unmanaged[Cdecl]<ImTextureID, nint>)funcTable[8])(texId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImTextureRefPtr ImTextureRef(ImTextureID texId)
		{
			ImTextureRefPtr ret = ImTextureRefNative(texId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImTextureID GetTexIDNative(ImTextureRef* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImTextureRef*, ImTextureID>)funcTable[9])(self);
			#else
			return (ImTextureID)((delegate* unmanaged[Cdecl]<nint, ImTextureID>)funcTable[9])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImTextureID GetTexID(ImTextureRefPtr self)
		{
			ImTextureID ret = GetTexIDNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImTextureID GetTexID(ref ImTextureRef self)
		{
			fixed (ImTextureRef* pself = &self)
			{
				ImTextureID ret = GetTexIDNative((ImTextureRef*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiContext* CreateContextNative(ImFontAtlas* sharedFontAtlas)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFontAtlas*, ImGuiContext*>)funcTable[10])(sharedFontAtlas);
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[10])((nint)sharedFontAtlas);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr CreateContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = CreateContextNative(sharedFontAtlas);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr CreateContext()
		{
			ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr CreateContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = CreateContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyContextNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[11])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[11])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DestroyContext(ImGuiContextPtr ctx)
		{
			DestroyContextNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DestroyContext()
		{
			DestroyContextNative((ImGuiContext*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DestroyContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				DestroyContextNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiContext* GetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*>)funcTable[12])();
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint>)funcTable[12])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr GetCurrentContext()
		{
			ImGuiContextPtr ret = GetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCurrentContextNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[13])(ctx);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[13])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentContext(ImGuiContextPtr ctx)
		{
			SetCurrentContextNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				SetCurrentContextNative((ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiIO* GetIONative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiIO*>)funcTable[14])();
			#else
			return (ImGuiIO*)((delegate* unmanaged[Cdecl]<nint>)funcTable[14])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiIOPtr GetIO()
		{
			ImGuiIOPtr ret = GetIONative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPlatformIO* GetPlatformIONative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiPlatformIO*>)funcTable[15])();
			#else
			return (ImGuiPlatformIO*)((delegate* unmanaged[Cdecl]<nint>)funcTable[15])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPlatformIOPtr GetPlatformIO()
		{
			ImGuiPlatformIOPtr ret = GetPlatformIONative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyle* GetStyleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyle*>)funcTable[16])();
			#else
			return (ImGuiStyle*)((delegate* unmanaged[Cdecl]<nint>)funcTable[16])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStylePtr GetStyle()
		{
			ImGuiStylePtr ret = GetStyleNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[17])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[17])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NewFrame()
		{
			NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[18])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[18])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndFrame()
		{
			EndFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[19])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[19])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Render()
		{
			RenderNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImDrawData* GetDrawDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawData*>)funcTable[20])();
			#else
			return (ImDrawData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[20])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawDataPtr GetDrawData()
		{
			ImDrawDataPtr ret = GetDrawDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowDemoWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)funcTable[21])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[21])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow(bool* pOpen)
		{
			ShowDemoWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow()
		{
			ShowDemoWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDemoWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowMetricsWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)funcTable[22])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[22])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow(bool* pOpen)
		{
			ShowMetricsWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow()
		{
			ShowMetricsWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowMetricsWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowMetricsWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowDebugLogWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)funcTable[23])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[23])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDebugLogWindow(bool* pOpen)
		{
			ShowDebugLogWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDebugLogWindow()
		{
			ShowDebugLogWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowDebugLogWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowDebugLogWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowIDStackToolWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)funcTable[24])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[24])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowIDStackToolWindow(bool* pOpen)
		{
			ShowIDStackToolWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowIDStackToolWindow()
		{
			ShowIDStackToolWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowIDStackToolWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowIDStackToolWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowAboutWindowNative(bool* pOpen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<bool*, void>)funcTable[25])(pOpen);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[25])((nint)pOpen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAboutWindow(bool* pOpen)
		{
			ShowAboutWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAboutWindow()
		{
			ShowAboutWindowNative((bool*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowAboutWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ShowAboutWindowNative((bool*)ppOpen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowStyleEditorNative(ImGuiStyle* reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)funcTable[26])(reference);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[26])((nint)reference);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor(ImGuiStylePtr reference)
		{
			ShowStyleEditorNative(reference);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor()
		{
			ShowStyleEditorNative((ImGuiStyle*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowStyleEditor(ref ImGuiStyle reference)
		{
			fixed (ImGuiStyle* preference = &reference)
			{
				ShowStyleEditorNative((ImGuiStyle*)preference);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowStyleSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[27])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[27])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(byte* label)
		{
			byte ret = ShowStyleSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ShowStyleSelectorNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowStyleSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowFontSelectorNative(byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[28])(label);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[28])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowFontSelector(byte* label)
		{
			ShowFontSelectorNative(label);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowFontSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ShowFontSelectorNative((byte*)plabel);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowFontSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ShowFontSelectorNative((byte*)plabel);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowFontSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowFontSelectorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowUserGuideNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[29])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[29])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShowUserGuide()
		{
			ShowUserGuideNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetVersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[30])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[30])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetVersion()
		{
			byte* ret = GetVersionNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetVersionS()
		{
			string ret = Utils.DecodeStringUTF8(GetVersionNative());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StyleColorsDarkNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)funcTable[31])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[31])((nint)dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsDark(ImGuiStylePtr dst)
		{
			StyleColorsDarkNative(dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsDark()
		{
			StyleColorsDarkNative((ImGuiStyle*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsDark(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsDarkNative((ImGuiStyle*)pdst);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StyleColorsLightNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)funcTable[32])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[32])((nint)dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsLight(ImGuiStylePtr dst)
		{
			StyleColorsLightNative(dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsLight()
		{
			StyleColorsLightNative((ImGuiStyle*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsLight(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsLightNative((ImGuiStyle*)pdst);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StyleColorsClassicNative(ImGuiStyle* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)funcTable[33])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[33])((nint)dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsClassic(ImGuiStylePtr dst)
		{
			StyleColorsClassicNative(dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsClassic()
		{
			StyleColorsClassicNative((ImGuiStyle*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StyleColorsClassic(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				StyleColorsClassicNative((ImGuiStyle*)pdst);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginNative(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, bool*, ImGuiWindowFlags, byte>)funcTable[34])(name, pOpen, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ImGuiWindowFlags, byte>)funcTable[34])((nint)name, (nint)pOpen, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, pOpen, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, bool* pOpen)
		{
			byte ret = BeginNative(name, pOpen, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name)
		{
			byte ret = BeginNative(name, (bool*)(default), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, ImGuiWindowFlags flags)
		{
			byte ret = BeginNative(name, (bool*)(default), flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, bool* pOpen)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = BeginNative((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginNative(pStr0, (bool*)(default), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(ReadOnlySpan<byte> name, ref bool pOpen)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = BeginNative((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Begin(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = BeginNative(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[35])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[35])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void End()
		{
			EndNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginChildNative(byte* strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)funcTable[36])(strId, size, childFlags, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)funcTable[36])((nint)strId, size, childFlags, windowFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, size, childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(strId, size, childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, Vector2 size)
		{
			byte ret = BeginChildNative(strId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, size, (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(byte* strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ref byte strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiChildFlags childFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, size, (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = BeginChildNative((byte*)pstrId, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, childFlags, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, ImGuiChildFlags childFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, size, (ImGuiChildFlags)(0), windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(string strId, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginChildNative(pStr0, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BeginChildNative(uint id, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)funcTable[37])(id, size, childFlags, windowFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, Vector2, ImGuiChildFlags, ImGuiWindowFlags, byte>)funcTable[37])(id, size, childFlags, windowFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, Vector2 size, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, size, childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, Vector2 size, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(id, size, childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, Vector2 size)
		{
			byte ret = BeginChildNative(id, size, (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, ImGuiChildFlags childFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), childFlags, (ImGuiWindowFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, Vector2 size, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, size, (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), (ImGuiChildFlags)(0), windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BeginChild(uint id, ImGuiChildFlags childFlags, ImGuiWindowFlags windowFlags)
		{
			byte ret = BeginChildNative(id, (Vector2)(new Vector2(0,0)), childFlags, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndChildNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[38])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[38])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndChild()
		{
			EndChildNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowAppearingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[39])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[39])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowAppearing()
		{
			byte ret = IsWindowAppearingNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowCollapsedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[40])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[40])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowCollapsed()
		{
			byte ret = IsWindowCollapsedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowFocusedNative(ImGuiFocusedFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiFocusedFlags, byte>)funcTable[41])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiFocusedFlags, byte>)funcTable[41])(flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowFocused(ImGuiFocusedFlags flags)
		{
			byte ret = IsWindowFocusedNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowFocused()
		{
			byte ret = IsWindowFocusedNative((ImGuiFocusedFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowHoveredNative(ImGuiHoveredFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)funcTable[42])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)funcTable[42])(flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowHovered(ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowHoveredNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowHovered()
		{
			byte ret = IsWindowHoveredNative((ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImDrawList* GetWindowDrawListNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawList*>)funcTable[43])();
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint>)funcTable[43])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawListPtr GetWindowDrawList()
		{
			ImDrawListPtr ret = GetWindowDrawListNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowDpiScaleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[44])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[44])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetWindowDpiScale()
		{
			float ret = GetWindowDpiScaleNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowPosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[45])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[45])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetWindowPos()
		{
			Vector2 ret;
			GetWindowPosNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWindowPos(Vector2* pOut)
		{
			GetWindowPosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWindowPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetWindowPosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWindowSizeNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[46])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[46])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetWindowSize()
		{
			Vector2 ret;
			GetWindowSizeNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWindowSize(Vector2* pOut)
		{
			GetWindowSizeNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWindowSize(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetWindowSizeNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[47])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[47])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetWindowWidth()
		{
			float ret = GetWindowWidthNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[48])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[48])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetWindowHeight()
		{
			float ret = GetWindowHeightNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiViewport* GetWindowViewportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*>)funcTable[49])();
			#else
			return (ImGuiViewport*)((delegate* unmanaged[Cdecl]<nint>)funcTable[49])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiViewportPtr GetWindowViewport()
		{
			ImGuiViewportPtr ret = GetWindowViewportNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowPosNative(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, Vector2, void>)funcTable[50])(pos, cond, pivot);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, Vector2, void>)funcTable[50])(pos, cond, pivot);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, cond, pivot);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetNextWindowPosNative(pos, cond, (Vector2)(new Vector2(0,0)));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowPos(Vector2 pos)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), (Vector2)(new Vector2(0,0)));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowPos(Vector2 pos, Vector2 pivot)
		{
			SetNextWindowPosNative(pos, (ImGuiCond)(0), pivot);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowSizeNative(Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)funcTable[51])(size, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)funcTable[51])(size, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetNextWindowSizeNative(size, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowSize(Vector2 size)
		{
			SetNextWindowSizeNative(size, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowSizeConstraintsNative(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, delegate*<ImGuiSizeCallbackData*, void>, void*, void>)funcTable[52])(sizeMin, sizeMax, (delegate*<ImGuiSizeCallbackData*, void>)Utils.GetFunctionPointerForDelegate(customCallback), customCallbackData);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, nint, nint, void>)funcTable[52])(sizeMin, sizeMax, (nint)Utils.GetFunctionPointerForDelegate(customCallback), (nint)customCallbackData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, customCallbackData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, (void*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), (void*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), customCallbackData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowContentSizeNative(Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[53])(size);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[53])(size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowContentSize(Vector2 size)
		{
			SetNextWindowContentSizeNative(size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowCollapsedNative(byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)funcTable[54])(collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)funcTable[54])(collapsed, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowCollapsed(bool collapsed)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowFocusNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[55])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[55])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowFocus()
		{
			SetNextWindowFocusNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowScrollNative(Vector2 scroll)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[56])(scroll);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[56])(scroll);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowScroll(Vector2 scroll)
		{
			SetNextWindowScrollNative(scroll);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowBgAlphaNative(float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[57])(alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[57])(alpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowBgAlpha(float alpha)
		{
			SetNextWindowBgAlphaNative(alpha);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowViewportNative(uint viewportId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[58])(viewportId);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[58])(viewportId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowViewport(uint viewportId)
		{
			SetNextWindowViewportNative(viewportId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowPosNative(Vector2 pos, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)funcTable[59])(pos, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)funcTable[59])(pos, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(pos, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(Vector2 pos)
		{
			SetWindowPosNative(pos, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowSizeNative(Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)funcTable[60])(size, cond);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, ImGuiCond, void>)funcTable[60])(size, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(size, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(Vector2 size)
		{
			SetWindowSizeNative(size, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowCollapsedNative(byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)funcTable[61])(collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)funcTable[61])(collapsed, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(bool collapsed)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowFocusNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[62])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[62])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowFocus()
		{
			SetWindowFocusNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowPosNative(byte* name, Vector2 pos, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiCond, void>)funcTable[63])(name, pos, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)funcTable[63])((nint)name, pos, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(byte* name, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(name, pos, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(byte* name, Vector2 pos)
		{
			SetWindowPosNative(name, pos, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(ref byte name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(ref byte name, Vector2 pos)
		{
			fixed (byte* pname = &name)
			{
				SetWindowPosNative((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(ReadOnlySpan<byte> name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowPosNative((byte*)pname, pos, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(ReadOnlySpan<byte> name, Vector2 pos)
		{
			fixed (byte* pname = name)
			{
				SetWindowPosNative((byte*)pname, pos, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(string name, Vector2 pos, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(string name, Vector2 pos)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowPosNative(pStr0, pos, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowSizeNative(byte* name, Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, Vector2, ImGuiCond, void>)funcTable[64])(name, size, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)funcTable[64])((nint)name, size, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(byte* name, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(name, size, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(byte* name, Vector2 size)
		{
			SetWindowSizeNative(name, size, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(ref byte name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(ref byte name, Vector2 size)
		{
			fixed (byte* pname = &name)
			{
				SetWindowSizeNative((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(ReadOnlySpan<byte> name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowSizeNative((byte*)pname, size, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(ReadOnlySpan<byte> name, Vector2 size)
		{
			fixed (byte* pname = name)
			{
				SetWindowSizeNative((byte*)pname, size, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(string name, Vector2 size, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(string name, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowSizeNative(pStr0, size, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowCollapsedNative(byte* name, byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte, ImGuiCond, void>)funcTable[65])(name, collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, ImGuiCond, void>)funcTable[65])((nint)name, collapsed, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(byte* name, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(byte* name, bool collapsed)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(ref byte name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(ref byte name, bool collapsed)
		{
			fixed (byte* pname = &name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(ReadOnlySpan<byte> name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(ReadOnlySpan<byte> name, bool collapsed)
		{
			fixed (byte* pname = name)
			{
				SetWindowCollapsedNative((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(string name, bool collapsed, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(string name, bool collapsed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowCollapsedNative(pStr0, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowFocusNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[66])(name);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[66])((nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowFocus(byte* name)
		{
			SetWindowFocusNative(name);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowFocus(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SetWindowFocusNative((byte*)pname);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowFocus(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SetWindowFocusNative((byte*)pname);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowFocus(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetWindowFocusNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetScrollXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[67])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[67])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetScrollX()
		{
			float ret = GetScrollXNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetScrollYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[68])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[68])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetScrollY()
		{
			float ret = GetScrollYNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollXNative(float scrollX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[69])(scrollX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[69])(scrollX);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollX(float scrollX)
		{
			SetScrollXNative(scrollX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollYNative(float scrollY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[70])(scrollY);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[70])(scrollY);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollY(float scrollY)
		{
			SetScrollYNative(scrollY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetScrollMaxXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[71])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[71])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetScrollMaxX()
		{
			float ret = GetScrollMaxXNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetScrollMaxYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[72])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[72])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetScrollMaxY()
		{
			float ret = GetScrollMaxYNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollHereXNative(float centerXRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[73])(centerXRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[73])(centerXRatio);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollHereX(float centerXRatio)
		{
			SetScrollHereXNative(centerXRatio);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollHereX()
		{
			SetScrollHereXNative((float)(0.5f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollHereYNative(float centerYRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[74])(centerYRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[74])(centerYRatio);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollHereY(float centerYRatio)
		{
			SetScrollHereYNative(centerYRatio);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollHereY()
		{
			SetScrollHereYNative((float)(0.5f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollFromPosXNative(float localX, float centerXRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[75])(localX, centerXRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[75])(localX, centerXRatio);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollFromPosX(float localX, float centerXRatio)
		{
			SetScrollFromPosXNative(localX, centerXRatio);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollFromPosX(float localX)
		{
			SetScrollFromPosXNative(localX, (float)(0.5f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollFromPosYNative(float localY, float centerYRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[76])(localY, centerYRatio);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[76])(localY, centerYRatio);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollFromPosY(float localY, float centerYRatio)
		{
			SetScrollFromPosYNative(localY, centerYRatio);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollFromPosY(float localY)
		{
			SetScrollFromPosYNative(localY, (float)(0.5f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushFontNative(ImFont* font, float fontSizeBaseUnscaled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImFont*, float, void>)funcTable[77])(font, fontSizeBaseUnscaled);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[77])((nint)font, fontSizeBaseUnscaled);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushFont(ImFontPtr font, float fontSizeBaseUnscaled)
		{
			PushFontNative(font, fontSizeBaseUnscaled);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushFont(ref ImFont font, float fontSizeBaseUnscaled)
		{
			fixed (ImFont* pfont = &font)
			{
				PushFontNative((ImFont*)pfont, fontSizeBaseUnscaled);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopFontNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[78])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[78])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopFont()
		{
			PopFontNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImFont* GetFontNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFont*>)funcTable[79])();
			#else
			return (ImFont*)((delegate* unmanaged[Cdecl]<nint>)funcTable[79])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFontPtr GetFont()
		{
			ImFontPtr ret = GetFontNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFontSizeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[80])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[80])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetFontSize()
		{
			float ret = GetFontSizeNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImFontBaked* GetFontBakedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFontBaked*>)funcTable[81])();
			#else
			return (ImFontBaked*)((delegate* unmanaged[Cdecl]<nint>)funcTable[81])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFontBakedPtr GetFontBaked()
		{
			ImFontBakedPtr ret = GetFontBakedNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushStyleColorNative(ImGuiCol idx, uint col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiCol, uint, void>)funcTable[82])(idx, col);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiCol, uint, void>)funcTable[82])(idx, col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushStyleColor(ImGuiCol idx, uint col)
		{
			PushStyleColorNative(idx, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushStyleColorNative(ImGuiCol idx, Vector4 col)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4, void>)funcTable[83])(idx, col);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4, void>)funcTable[83])(idx, col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushStyleColor(ImGuiCol idx, Vector4 col)
		{
			PushStyleColorNative(idx, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopStyleColorNative(int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[84])(count);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[84])(count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopStyleColor(int count)
		{
			PopStyleColorNative(count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopStyleColor()
		{
			PopStyleColorNative((int)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushStyleVarNative(ImGuiStyleVar idx, float val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)funcTable[85])(idx, val);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)funcTable[85])(idx, val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushStyleVar(ImGuiStyleVar idx, float val)
		{
			PushStyleVarNative(idx, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushStyleVarNative(ImGuiStyleVar idx, Vector2 val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, void>)funcTable[86])(idx, val);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, void>)funcTable[86])(idx, val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushStyleVar(ImGuiStyleVar idx, Vector2 val)
		{
			PushStyleVarNative(idx, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushStyleVarXNative(ImGuiStyleVar idx, float valX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)funcTable[87])(idx, valX);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)funcTable[87])(idx, valX);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushStyleVarX(ImGuiStyleVar idx, float valX)
		{
			PushStyleVarXNative(idx, valX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushStyleVarYNative(ImGuiStyleVar idx, float valY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)funcTable[88])(idx, valY);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, void>)funcTable[88])(idx, valY);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushStyleVarY(ImGuiStyleVar idx, float valY)
		{
			PushStyleVarYNative(idx, valY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopStyleVarNative(int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[89])(count);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[89])(count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopStyleVar(int count)
		{
			PopStyleVarNative(count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopStyleVar()
		{
			PopStyleVarNative((int)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushItemFlagNative(ImGuiItemFlags option, byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiItemFlags, byte, void>)funcTable[90])(option, enabled);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiItemFlags, byte, void>)funcTable[90])(option, enabled);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushItemFlag(ImGuiItemFlags option, bool enabled)
		{
			PushItemFlagNative(option, enabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopItemFlagNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[91])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[91])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopItemFlag()
		{
			PopItemFlagNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushItemWidthNative(float itemWidth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[92])(itemWidth);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[92])(itemWidth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushItemWidth(float itemWidth)
		{
			PushItemWidthNative(itemWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopItemWidthNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[93])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[93])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopItemWidth()
		{
			PopItemWidthNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextItemWidthNative(float itemWidth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[94])(itemWidth);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[94])(itemWidth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextItemWidth(float itemWidth)
		{
			SetNextItemWidthNative(itemWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CalcItemWidthNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[95])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[95])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float CalcItemWidth()
		{
			float ret = CalcItemWidthNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushTextWrapPosNative(float wrapLocalPosX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[96])(wrapLocalPosX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[96])(wrapLocalPosX);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushTextWrapPos(float wrapLocalPosX)
		{
			PushTextWrapPosNative(wrapLocalPosX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushTextWrapPos()
		{
			PushTextWrapPosNative((float)(0.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopTextWrapPosNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[97])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[97])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopTextWrapPos()
		{
			PopTextWrapPosNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFontTexUvWhitePixelNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[98])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[98])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetFontTexUvWhitePixel()
		{
			Vector2 ret;
			GetFontTexUvWhitePixelNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetFontTexUvWhitePixel(Vector2* pOut)
		{
			GetFontTexUvWhitePixelNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetFontTexUvWhitePixel(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetFontTexUvWhitePixelNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetColorU32Native(ImGuiCol idx, float alphaMul)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiCol, float, uint>)funcTable[99])(idx, alphaMul);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<ImGuiCol, float, uint>)funcTable[99])(idx, alphaMul);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColorU32(ImGuiCol idx, float alphaMul)
		{
			uint ret = GetColorU32Native(idx, alphaMul);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColorU32(ImGuiCol idx)
		{
			uint ret = GetColorU32Native(idx, (float)(1.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetColorU32Native(Vector4 col)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, uint>)funcTable[100])(col);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<Vector4, uint>)funcTable[100])(col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColorU32(Vector4 col)
		{
			uint ret = GetColorU32Native(col);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetColorU32Native(uint col, float alphaMul)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, float, uint>)funcTable[101])(col, alphaMul);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, float, uint>)funcTable[101])(col, alphaMul);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColorU32(uint col, float alphaMul)
		{
			uint ret = GetColorU32Native(col, alphaMul);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColorU32(uint col)
		{
			uint ret = GetColorU32Native(col, (float)(1.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector4* GetStyleColorVec4Native(ImGuiCol idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiCol, Vector4*>)funcTable[102])(idx);
			#else
			return (Vector4*)((delegate* unmanaged[Cdecl]<ImGuiCol, nint>)funcTable[102])(idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4* GetStyleColorVec4(ImGuiCol idx)
		{
			Vector4* ret = GetStyleColorVec4Native(idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCursorScreenPosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[103])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[103])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetCursorScreenPos()
		{
			Vector2 ret;
			GetCursorScreenPosNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCursorScreenPos(Vector2* pOut)
		{
			GetCursorScreenPosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCursorScreenPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetCursorScreenPosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCursorScreenPosNative(Vector2 pos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[104])(pos);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[104])(pos);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCursorScreenPos(Vector2 pos)
		{
			SetCursorScreenPosNative(pos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetContentRegionAvailNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[105])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[105])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetContentRegionAvail()
		{
			Vector2 ret;
			GetContentRegionAvailNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetContentRegionAvail(Vector2* pOut)
		{
			GetContentRegionAvailNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetContentRegionAvail(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetContentRegionAvailNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCursorPosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[106])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[106])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetCursorPos()
		{
			Vector2 ret;
			GetCursorPosNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCursorPos(Vector2* pOut)
		{
			GetCursorPosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCursorPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetCursorPosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetCursorPosXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[107])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[107])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetCursorPosX()
		{
			float ret = GetCursorPosXNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetCursorPosYNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[108])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[108])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetCursorPosY()
		{
			float ret = GetCursorPosYNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCursorPosNative(Vector2 localPos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[109])(localPos);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[109])(localPos);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCursorPos(Vector2 localPos)
		{
			SetCursorPosNative(localPos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCursorPosXNative(float localX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[110])(localX);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[110])(localX);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCursorPosX(float localX)
		{
			SetCursorPosXNative(localX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCursorPosYNative(float localY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[111])(localY);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[111])(localY);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCursorPosY(float localY)
		{
			SetCursorPosYNative(localY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCursorStartPosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[112])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[112])((nint)pOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetCursorStartPos()
		{
			Vector2 ret;
			GetCursorStartPosNative(&ret);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCursorStartPos(Vector2* pOut)
		{
			GetCursorStartPosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCursorStartPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetCursorStartPosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SeparatorNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[113])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[113])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Separator()
		{
			SeparatorNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SameLineNative(float offsetFromStartX, float spacing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[114])(offsetFromStartX, spacing);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[114])(offsetFromStartX, spacing);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SameLine(float offsetFromStartX, float spacing)
		{
			SameLineNative(offsetFromStartX, spacing);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SameLine(float offsetFromStartX)
		{
			SameLineNative(offsetFromStartX, (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SameLine()
		{
			SameLineNative((float)(0.0f), (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NewLineNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[115])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[115])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void NewLine()
		{
			NewLineNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SpacingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[116])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[116])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Spacing()
		{
			SpacingNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DummyNative(Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[117])(size);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[117])(size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Dummy(Vector2 size)
		{
			DummyNative(size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndentNative(float indentW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[118])(indentW);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[118])(indentW);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Indent(float indentW)
		{
			IndentNative(indentW);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Indent()
		{
			IndentNative((float)(0.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnindentNative(float indentW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[119])(indentW);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[119])(indentW);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Unindent(float indentW)
		{
			UnindentNative(indentW);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Unindent()
		{
			UnindentNative((float)(0.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginGroupNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[120])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[120])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginGroup()
		{
			BeginGroupNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndGroupNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[121])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[121])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndGroup()
		{
			EndGroupNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlignTextToFramePaddingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[122])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[122])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AlignTextToFramePadding()
		{
			AlignTextToFramePaddingNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetTextLineHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[123])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[123])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetTextLineHeight()
		{
			float ret = GetTextLineHeightNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetTextLineHeightWithSpacingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[124])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[124])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetTextLineHeightWithSpacing()
		{
			float ret = GetTextLineHeightWithSpacingNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFrameHeightNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[125])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[125])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetFrameHeight()
		{
			float ret = GetFrameHeightNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFrameHeightWithSpacingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[126])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[126])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetFrameHeightWithSpacing()
		{
			float ret = GetFrameHeightWithSpacingNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushIDNative(byte* strId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[127])(strId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[127])((nint)strId);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strId)
		{
			PushIDNative(strId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				PushIDNative((byte*)pstrId);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushIDNative(byte* strIdBegin, byte* strIdEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, byte*, void>)funcTable[128])(strIdBegin, strIdEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[128])((nint)strIdBegin, (nint)strIdEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strIdBegin, byte* strIdEnd)
		{
			PushIDNative(strIdBegin, strIdEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ref byte strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				PushIDNative((byte*)pstrIdBegin, strIdEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(string strIdBegin, byte* strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(pStr0, strIdEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(byte* strIdBegin, string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushID(ref byte strIdBegin, ref byte strIdEnd)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					PushIDNative((byte*)pstrIdBegin, (byte*)pstrIdEnd);
				}
			}
		}
	}
}
