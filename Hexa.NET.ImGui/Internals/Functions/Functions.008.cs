// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGuiP
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowPosNative(ImGuiWindow* window, Vector2 pos, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, Vector2, ImGuiCond, void>)funcTable[1018])(window, pos, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)funcTable[1018])((nint)window, pos, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(ImGuiWindowPtr window, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(window, pos, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(ImGuiWindowPtr window, Vector2 pos)
		{
			SetWindowPosNative(window, pos, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(ref ImGuiWindow window, Vector2 pos, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowPosNative((ImGuiWindow*)pwindow, pos, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowPos(ref ImGuiWindow window, Vector2 pos)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowPosNative((ImGuiWindow*)pwindow, pos, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowSizeNative(ImGuiWindow* window, Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, Vector2, ImGuiCond, void>)funcTable[1019])(window, size, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)funcTable[1019])((nint)window, size, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(ImGuiWindowPtr window, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(window, size, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(ImGuiWindowPtr window, Vector2 size)
		{
			SetWindowSizeNative(window, size, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(ref ImGuiWindow window, Vector2 size, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowSizeNative((ImGuiWindow*)pwindow, size, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowSize(ref ImGuiWindow window, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowSizeNative((ImGuiWindow*)pwindow, size, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowCollapsedNative(ImGuiWindow* window, byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte, ImGuiCond, void>)funcTable[1020])(window, collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, ImGuiCond, void>)funcTable[1020])((nint)window, collapsed, cond);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(ImGuiWindowPtr window, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(window, collapsed ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(ImGuiWindowPtr window, bool collapsed)
		{
			SetWindowCollapsedNative(window, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(ref ImGuiWindow window, bool collapsed, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowCollapsedNative((ImGuiWindow*)pwindow, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowCollapsed(ref ImGuiWindow window, bool collapsed)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowCollapsedNative((ImGuiWindow*)pwindow, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowHitTestHoleNative(ImGuiWindow* window, Vector2 pos, Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, Vector2, Vector2, void>)funcTable[1021])(window, pos, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, void>)funcTable[1021])((nint)window, pos, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowHitTestHole(ImGuiWindowPtr window, Vector2 pos, Vector2 size)
		{
			SetWindowHitTestHoleNative(window, pos, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowHitTestHole(ref ImGuiWindow window, Vector2 pos, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHitTestHoleNative((ImGuiWindow*)pwindow, pos, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowHiddenAndSkipItemsForCurrentFrameNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1022])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1022])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowHiddenAndSkipItemsForCurrentFrame(ImGuiWindowPtr window)
		{
			SetWindowHiddenAndSkipItemsForCurrentFrameNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowHiddenAndSkipItemsForCurrentFrame(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHiddenAndSkipItemsForCurrentFrameNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowParentWindowForFocusRouteNative(ImGuiWindow* window, ImGuiWindow* parentWindow)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*, void>)funcTable[1023])(window, parentWindow);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1023])((nint)window, (nint)parentWindow);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowParentWindowForFocusRoute(ImGuiWindowPtr window, ImGuiWindowPtr parentWindow)
		{
			SetWindowParentWindowForFocusRouteNative(window, parentWindow);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowParentWindowForFocusRoute(ref ImGuiWindow window, ImGuiWindowPtr parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowParentWindowForFocusRouteNative((ImGuiWindow*)pwindow, parentWindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowParentWindowForFocusRoute(ImGuiWindowPtr window, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pparentWindow = &parentWindow)
			{
				SetWindowParentWindowForFocusRouteNative(window, (ImGuiWindow*)pparentWindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowParentWindowForFocusRoute(ref ImGuiWindow window, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* pparentWindow = &parentWindow)
				{
					SetWindowParentWindowForFocusRouteNative((ImGuiWindow*)pwindow, (ImGuiWindow*)pparentWindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowRectAbsToRelNative(ImRect* pOut, ImGuiWindow* window, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, ImRect, void>)funcTable[1024])(pOut, window, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, ImRect, void>)funcTable[1024])((nint)pOut, (nint)window, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect WindowRectAbsToRel(ImGuiWindowPtr window, ImRect r)
		{
			ImRect ret;
			WindowRectAbsToRelNative(&ret, window, r);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectAbsToRel(ImRectPtr pOut, ImGuiWindowPtr window, ImRect r)
		{
			WindowRectAbsToRelNative(pOut, window, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectAbsToRel(ref ImRect pOut, ImGuiWindowPtr window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				WindowRectAbsToRelNative((ImRect*)ppOut, window, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect WindowRectAbsToRel(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				WindowRectAbsToRelNative(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectAbsToRel(ImRectPtr pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowRectAbsToRelNative(pOut, (ImGuiWindow*)pwindow, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectAbsToRel(ref ImRect pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectAbsToRelNative((ImRect*)ppOut, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowRectRelToAbsNative(ImRect* pOut, ImGuiWindow* window, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, ImRect, void>)funcTable[1025])(pOut, window, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, ImRect, void>)funcTable[1025])((nint)pOut, (nint)window, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect WindowRectRelToAbs(ImGuiWindowPtr window, ImRect r)
		{
			ImRect ret;
			WindowRectRelToAbsNative(&ret, window, r);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectRelToAbs(ImRectPtr pOut, ImGuiWindowPtr window, ImRect r)
		{
			WindowRectRelToAbsNative(pOut, window, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectRelToAbs(ref ImRect pOut, ImGuiWindowPtr window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				WindowRectRelToAbsNative((ImRect*)ppOut, window, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect WindowRectRelToAbs(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				WindowRectRelToAbsNative(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectRelToAbs(ImRectPtr pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowRectRelToAbsNative(pOut, (ImGuiWindow*)pwindow, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectRelToAbs(ref ImRect pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectRelToAbsNative((ImRect*)ppOut, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPosAbsToRelNative(Vector2* pOut, ImGuiWindow* window, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiWindow*, Vector2, void>)funcTable[1026])(pOut, window, p);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, void>)funcTable[1026])((nint)pOut, (nint)window, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 WindowPosAbsToRel(ImGuiWindowPtr window, Vector2 p)
		{
			Vector2 ret;
			WindowPosAbsToRelNative(&ret, window, p);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowPosAbsToRel(Vector2* pOut, ImGuiWindowPtr window, Vector2 p)
		{
			WindowPosAbsToRelNative(pOut, window, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowPosAbsToRel(ref Vector2 pOut, ImGuiWindowPtr window, Vector2 p)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				WindowPosAbsToRelNative((Vector2*)ppOut, window, p);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 WindowPosAbsToRel(ref ImGuiWindow window, Vector2 p)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				WindowPosAbsToRelNative(&ret, (ImGuiWindow*)pwindow, p);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowPosAbsToRel(Vector2* pOut, ref ImGuiWindow window, Vector2 p)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowPosAbsToRelNative(pOut, (ImGuiWindow*)pwindow, p);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowPosAbsToRel(ref Vector2 pOut, ref ImGuiWindow window, Vector2 p)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowPosAbsToRelNative((Vector2*)ppOut, (ImGuiWindow*)pwindow, p);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPosRelToAbsNative(Vector2* pOut, ImGuiWindow* window, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiWindow*, Vector2, void>)funcTable[1027])(pOut, window, p);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, void>)funcTable[1027])((nint)pOut, (nint)window, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 WindowPosRelToAbs(ImGuiWindowPtr window, Vector2 p)
		{
			Vector2 ret;
			WindowPosRelToAbsNative(&ret, window, p);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowPosRelToAbs(Vector2* pOut, ImGuiWindowPtr window, Vector2 p)
		{
			WindowPosRelToAbsNative(pOut, window, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowPosRelToAbs(ref Vector2 pOut, ImGuiWindowPtr window, Vector2 p)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				WindowPosRelToAbsNative((Vector2*)ppOut, window, p);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 WindowPosRelToAbs(ref ImGuiWindow window, Vector2 p)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				WindowPosRelToAbsNative(&ret, (ImGuiWindow*)pwindow, p);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowPosRelToAbs(Vector2* pOut, ref ImGuiWindow window, Vector2 p)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowPosRelToAbsNative(pOut, (ImGuiWindow*)pwindow, p);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowPosRelToAbs(ref Vector2 pOut, ref ImGuiWindow window, Vector2 p)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowPosRelToAbsNative((Vector2*)ppOut, (ImGuiWindow*)pwindow, p);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FocusWindowNative(ImGuiWindow* window, ImGuiFocusRequestFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiFocusRequestFlags, void>)funcTable[1028])(window, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiFocusRequestFlags, void>)funcTable[1028])((nint)window, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusWindow(ImGuiWindowPtr window, ImGuiFocusRequestFlags flags)
		{
			FocusWindowNative(window, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusWindow(ImGuiWindowPtr window)
		{
			FocusWindowNative(window, (ImGuiFocusRequestFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusWindow(ref ImGuiWindow window, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				FocusWindowNative((ImGuiWindow*)pwindow, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				FocusWindowNative((ImGuiWindow*)pwindow, (ImGuiFocusRequestFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FocusTopMostWindowUnderOneNative(ImGuiWindow* underThisWindow, ImGuiWindow* ignoreWindow, ImGuiViewport* filterViewport, ImGuiFocusRequestFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*, ImGuiViewport*, ImGuiFocusRequestFlags, void>)funcTable[1029])(underThisWindow, ignoreWindow, filterViewport, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, ImGuiFocusRequestFlags, void>)funcTable[1029])((nint)underThisWindow, (nint)ignoreWindow, (nint)filterViewport, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ImGuiWindowPtr ignoreWindow, ImGuiViewportPtr filterViewport, ImGuiFocusRequestFlags flags)
		{
			FocusTopMostWindowUnderOneNative(underThisWindow, ignoreWindow, filterViewport, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindowPtr ignoreWindow, ImGuiViewportPtr filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, ignoreWindow, filterViewport, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ref ImGuiWindow ignoreWindow, ImGuiViewportPtr filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				FocusTopMostWindowUnderOneNative(underThisWindow, (ImGuiWindow*)pignoreWindow, filterViewport, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow, ImGuiViewportPtr filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow, filterViewport, flags);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ImGuiWindowPtr ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiViewport* pfilterViewport = &filterViewport)
			{
				FocusTopMostWindowUnderOneNative(underThisWindow, ignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindowPtr ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiViewport* pfilterViewport = &filterViewport)
				{
					FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, ignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ref ImGuiWindow ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				fixed (ImGuiViewport* pfilterViewport = &filterViewport)
				{
					FocusTopMostWindowUnderOneNative(underThisWindow, (ImGuiWindow*)pignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow, ref ImGuiViewport filterViewport, ImGuiFocusRequestFlags flags)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					fixed (ImGuiViewport* pfilterViewport = &filterViewport)
					{
						FocusTopMostWindowUnderOneNative((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow, (ImGuiViewport*)pfilterViewport, flags);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BringWindowToFocusFrontNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1030])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1030])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToFocusFront(ImGuiWindowPtr window)
		{
			BringWindowToFocusFrontNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToFocusFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToFocusFrontNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BringWindowToDisplayFrontNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1031])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1031])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToDisplayFront(ImGuiWindowPtr window)
		{
			BringWindowToDisplayFrontNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToDisplayFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayFrontNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BringWindowToDisplayBackNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1032])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1032])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToDisplayBack(ImGuiWindowPtr window)
		{
			BringWindowToDisplayBackNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToDisplayBack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayBackNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BringWindowToDisplayBehindNative(ImGuiWindow* window, ImGuiWindow* aboveWindow)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*, void>)funcTable[1033])(window, aboveWindow);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1033])((nint)window, (nint)aboveWindow);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToDisplayBehind(ImGuiWindowPtr window, ImGuiWindowPtr aboveWindow)
		{
			BringWindowToDisplayBehindNative(window, aboveWindow);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ImGuiWindowPtr aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				BringWindowToDisplayBehindNative((ImGuiWindow*)pwindow, aboveWindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToDisplayBehind(ImGuiWindowPtr window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* paboveWindow = &aboveWindow)
			{
				BringWindowToDisplayBehindNative(window, (ImGuiWindow*)paboveWindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* paboveWindow = &aboveWindow)
				{
					BringWindowToDisplayBehindNative((ImGuiWindow*)pwindow, (ImGuiWindow*)paboveWindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FindWindowDisplayIndexNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, int>)funcTable[1034])(window);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[1034])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FindWindowDisplayIndex(ImGuiWindowPtr window)
		{
			int ret = FindWindowDisplayIndexNative(window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FindWindowDisplayIndex(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = FindWindowDisplayIndexNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* FindBottomMostVisibleWindowWithinBeginStackNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*>)funcTable[1035])(window);
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1035])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindowPtr window)
		{
			ImGuiWindowPtr ret = FindBottomMostVisibleWindowWithinBeginStackNative(window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindBottomMostVisibleWindowWithinBeginStack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowPtr ret = FindBottomMostVisibleWindowWithinBeginStackNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextWindowRefreshPolicyNative(ImGuiWindowRefreshFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindowRefreshFlags, void>)funcTable[1036])(flags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiWindowRefreshFlags, void>)funcTable[1036])(flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextWindowRefreshPolicy(ImGuiWindowRefreshFlags flags)
		{
			SetNextWindowRefreshPolicyNative(flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RegisterUserTextureNative(ImTextureData* tex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImTextureData*, void>)funcTable[1037])(tex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1037])((nint)tex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RegisterUserTexture(ImTextureDataPtr tex)
		{
			RegisterUserTextureNative(tex);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RegisterUserTexture(ref ImTextureData tex)
		{
			fixed (ImTextureData* ptex = &tex)
			{
				RegisterUserTextureNative((ImTextureData*)ptex);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnregisterUserTextureNative(ImTextureData* tex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImTextureData*, void>)funcTable[1038])(tex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1038])((nint)tex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UnregisterUserTexture(ImTextureDataPtr tex)
		{
			UnregisterUserTextureNative(tex);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UnregisterUserTexture(ref ImTextureData tex)
		{
			fixed (ImTextureData* ptex = &tex)
			{
				UnregisterUserTextureNative((ImTextureData*)ptex);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RegisterFontAtlasNative(ImFontAtlas* atlas)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImFontAtlas*, void>)funcTable[1039])(atlas);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1039])((nint)atlas);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RegisterFontAtlas(ImFontAtlasPtr atlas)
		{
			RegisterFontAtlasNative(atlas);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RegisterFontAtlas(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				RegisterFontAtlasNative((ImFontAtlas*)patlas);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnregisterFontAtlasNative(ImFontAtlas* atlas)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImFontAtlas*, void>)funcTable[1040])(atlas);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1040])((nint)atlas);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UnregisterFontAtlas(ImFontAtlasPtr atlas)
		{
			UnregisterFontAtlasNative(atlas);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UnregisterFontAtlas(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				UnregisterFontAtlasNative((ImFontAtlas*)patlas);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCurrentFontNative(ImFont* font, float fontSizeBeforeScaling, float fontSizeAfterScaling)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImFont*, float, float, void>)funcTable[1041])(font, fontSizeBeforeScaling, fontSizeAfterScaling);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, void>)funcTable[1041])((nint)font, fontSizeBeforeScaling, fontSizeAfterScaling);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentFont(ImFontPtr font, float fontSizeBeforeScaling, float fontSizeAfterScaling)
		{
			SetCurrentFontNative(font, fontSizeBeforeScaling, fontSizeAfterScaling);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentFont(ref ImFont font, float fontSizeBeforeScaling, float fontSizeAfterScaling)
		{
			fixed (ImFont* pfont = &font)
			{
				SetCurrentFontNative((ImFont*)pfont, fontSizeBeforeScaling, fontSizeAfterScaling);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateCurrentFontSizeNative(float restoreFontSizeAfterScaling)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[1042])(restoreFontSizeAfterScaling);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[1042])(restoreFontSizeAfterScaling);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateCurrentFontSize(float restoreFontSizeAfterScaling)
		{
			UpdateCurrentFontSizeNative(restoreFontSizeAfterScaling);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFontRasterizerDensityNative(float rasterizerDensity)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[1043])(rasterizerDensity);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[1043])(rasterizerDensity);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetFontRasterizerDensity(float rasterizerDensity)
		{
			SetFontRasterizerDensityNative(rasterizerDensity);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFontRasterizerDensityNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[1044])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[1044])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetFontRasterizerDensity()
		{
			float ret = GetFontRasterizerDensityNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetRoundedFontSizeNative(float size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[1045])(size);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[1045])(size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetRoundedFontSize(float size)
		{
			float ret = GetRoundedFontSizeNative(size);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImFont* GetDefaultFontNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFont*>)funcTable[1046])();
			#else
			return (ImFont*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1046])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFontPtr GetDefaultFont()
		{
			ImFontPtr ret = GetDefaultFontNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushPasswordFontNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1047])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1047])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushPasswordFont()
		{
			PushPasswordFontNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopPasswordFontNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1048])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1048])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PopPasswordFont()
		{
			PopPasswordFontNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImDrawList* GetForegroundDrawListNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImDrawList*>)funcTable[1049])(window);
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1049])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawListPtr GetForegroundDrawList(ImGuiWindowPtr window)
		{
			ImDrawListPtr ret = GetForegroundDrawListNative(window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawListPtr GetForegroundDrawList(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImDrawListPtr ret = GetForegroundDrawListNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddDrawListToDrawDataExNative(ImDrawData* drawData, ImVector<ImDrawListPtr>* outList, ImDrawList* drawList)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawData*, ImVector<ImDrawListPtr>*, ImDrawList*, void>)funcTable[1050])(drawData, outList, drawList);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1050])((nint)drawData, (nint)outList, (nint)drawList);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddDrawListToDrawDataEx(ImDrawDataPtr drawData, ImVector<ImDrawListPtr>* outList, ImDrawListPtr drawList)
		{
			AddDrawListToDrawDataExNative(drawData, outList, drawList);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddDrawListToDrawDataEx(ref ImDrawData drawData, ImVector<ImDrawListPtr>* outList, ImDrawListPtr drawList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				AddDrawListToDrawDataExNative((ImDrawData*)pdrawData, outList, drawList);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddDrawListToDrawDataEx(ImDrawDataPtr drawData, ref ImVector<ImDrawListPtr> outList, ImDrawListPtr drawList)
		{
			fixed (ImVector<ImDrawListPtr>* poutList = &outList)
			{
				AddDrawListToDrawDataExNative(drawData, (ImVector<ImDrawListPtr>*)poutList, drawList);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddDrawListToDrawDataEx(ref ImDrawData drawData, ref ImVector<ImDrawListPtr> outList, ImDrawListPtr drawList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (ImVector<ImDrawListPtr>* poutList = &outList)
				{
					AddDrawListToDrawDataExNative((ImDrawData*)pdrawData, (ImVector<ImDrawListPtr>*)poutList, drawList);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddDrawListToDrawDataEx(ImDrawDataPtr drawData, ImVector<ImDrawListPtr>* outList, ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				AddDrawListToDrawDataExNative(drawData, outList, (ImDrawList*)pdrawList);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddDrawListToDrawDataEx(ref ImDrawData drawData, ImVector<ImDrawListPtr>* outList, ref ImDrawList drawList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					AddDrawListToDrawDataExNative((ImDrawData*)pdrawData, outList, (ImDrawList*)pdrawList);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddDrawListToDrawDataEx(ImDrawDataPtr drawData, ref ImVector<ImDrawListPtr> outList, ref ImDrawList drawList)
		{
			fixed (ImVector<ImDrawListPtr>* poutList = &outList)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					AddDrawListToDrawDataExNative(drawData, (ImVector<ImDrawListPtr>*)poutList, (ImDrawList*)pdrawList);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddDrawListToDrawDataEx(ref ImDrawData drawData, ref ImVector<ImDrawListPtr> outList, ref ImDrawList drawList)
		{
			fixed (ImDrawData* pdrawData = &drawData)
			{
				fixed (ImVector<ImDrawListPtr>* poutList = &outList)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						AddDrawListToDrawDataExNative((ImDrawData*)pdrawData, (ImVector<ImDrawListPtr>*)poutList, (ImDrawList*)pdrawList);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InitializeNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1051])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1051])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Initialize()
		{
			InitializeNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShutdownNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1052])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1052])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Shutdown()
		{
			ShutdownNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateInputEventsNative(byte trickleFastInputs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[1053])(trickleFastInputs);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[1053])(trickleFastInputs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateInputEvents(bool trickleFastInputs)
		{
			UpdateInputEventsNative(trickleFastInputs ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateHoveredWindowAndCaptureFlagsNative(Vector2 mousePos)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[1054])(mousePos);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, void>)funcTable[1054])(mousePos);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateHoveredWindowAndCaptureFlags(Vector2 mousePos)
		{
			UpdateHoveredWindowAndCaptureFlagsNative(mousePos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FindHoveredWindowExNative(Vector2 pos, byte findFirstAndInAnyViewport, ImGuiWindow** outHoveredWindow, ImGuiWindow** outHoveredWindowUnderMovingWindow)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, byte, ImGuiWindow**, ImGuiWindow**, void>)funcTable[1055])(pos, findFirstAndInAnyViewport, outHoveredWindow, outHoveredWindowUnderMovingWindow);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, byte, nint, nint, void>)funcTable[1055])(pos, findFirstAndInAnyViewport, (nint)outHoveredWindow, (nint)outHoveredWindowUnderMovingWindow);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindHoveredWindowEx(Vector2 pos, bool findFirstAndInAnyViewport, ImGuiWindowPtrPtr outHoveredWindow, ImGuiWindowPtrPtr outHoveredWindowUnderMovingWindow)
		{
			FindHoveredWindowExNative(pos, findFirstAndInAnyViewport ? (byte)1 : (byte)0, outHoveredWindow, outHoveredWindowUnderMovingWindow);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindHoveredWindowEx(Vector2 pos, bool findFirstAndInAnyViewport, ref ImGuiWindow* outHoveredWindow, ImGuiWindowPtrPtr outHoveredWindowUnderMovingWindow)
		{
			fixed (ImGuiWindow** poutHoveredWindow = &outHoveredWindow)
			{
				FindHoveredWindowExNative(pos, findFirstAndInAnyViewport ? (byte)1 : (byte)0, (ImGuiWindow**)poutHoveredWindow, outHoveredWindowUnderMovingWindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindHoveredWindowEx(Vector2 pos, bool findFirstAndInAnyViewport, ImGuiWindowPtrPtr outHoveredWindow, ref ImGuiWindow* outHoveredWindowUnderMovingWindow)
		{
			fixed (ImGuiWindow** poutHoveredWindowUnderMovingWindow = &outHoveredWindowUnderMovingWindow)
			{
				FindHoveredWindowExNative(pos, findFirstAndInAnyViewport ? (byte)1 : (byte)0, outHoveredWindow, (ImGuiWindow**)poutHoveredWindowUnderMovingWindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FindHoveredWindowEx(Vector2 pos, bool findFirstAndInAnyViewport, ref ImGuiWindow* outHoveredWindow, ref ImGuiWindow* outHoveredWindowUnderMovingWindow)
		{
			fixed (ImGuiWindow** poutHoveredWindow = &outHoveredWindow)
			{
				fixed (ImGuiWindow** poutHoveredWindowUnderMovingWindow = &outHoveredWindowUnderMovingWindow)
				{
					FindHoveredWindowExNative(pos, findFirstAndInAnyViewport ? (byte)1 : (byte)0, (ImGuiWindow**)poutHoveredWindow, (ImGuiWindow**)poutHoveredWindowUnderMovingWindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StartMouseMovingWindowNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1056])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1056])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StartMouseMovingWindow(ImGuiWindowPtr window)
		{
			StartMouseMovingWindowNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StartMouseMovingWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				StartMouseMovingWindowNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StartMouseMovingWindowOrNodeNative(ImGuiWindow* window, ImGuiDockNode* node, byte undock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiDockNode*, byte, void>)funcTable[1057])(window, node, undock);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, byte, void>)funcTable[1057])((nint)window, (nint)node, undock);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StartMouseMovingWindowOrNode(ImGuiWindowPtr window, ImGuiDockNodePtr node, bool undock)
		{
			StartMouseMovingWindowOrNodeNative(window, node, undock ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ImGuiDockNodePtr node, bool undock)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				StartMouseMovingWindowOrNodeNative((ImGuiWindow*)pwindow, node, undock ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StartMouseMovingWindowOrNode(ImGuiWindowPtr window, ref ImGuiDockNode node, bool undock)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				StartMouseMovingWindowOrNodeNative(window, (ImGuiDockNode*)pnode, undock ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ref ImGuiDockNode node, bool undock)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					StartMouseMovingWindowOrNodeNative((ImGuiWindow*)pwindow, (ImGuiDockNode*)pnode, undock ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateMouseMovingWindowNewFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1058])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1058])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateMouseMovingWindowNewFrame()
		{
			UpdateMouseMovingWindowNewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateMouseMovingWindowEndFrameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1059])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1059])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateMouseMovingWindowEndFrame()
		{
			UpdateMouseMovingWindowEndFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint AddContextHookNative(ImGuiContext* context, ImGuiContextHook* hook)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiContextHook*, uint>)funcTable[1060])(context, hook);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[1060])((nint)context, (nint)hook);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddContextHook(ImGuiContextPtr context, ImGuiContextHookPtr hook)
		{
			uint ret = AddContextHookNative(context, hook);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddContextHook(ref ImGuiContext context, ImGuiContextHookPtr hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				uint ret = AddContextHookNative((ImGuiContext*)pcontext, hook);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddContextHook(ImGuiContextPtr context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContextHook* phook = &hook)
			{
				uint ret = AddContextHookNative(context, (ImGuiContextHook*)phook);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint AddContextHook(ref ImGuiContext context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (ImGuiContextHook* phook = &hook)
				{
					uint ret = AddContextHookNative((ImGuiContext*)pcontext, (ImGuiContextHook*)phook);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RemoveContextHookNative(ImGuiContext* context, uint hookToRemove)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, uint, void>)funcTable[1061])(context, hookToRemove);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[1061])((nint)context, hookToRemove);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RemoveContextHook(ImGuiContextPtr context, uint hookToRemove)
		{
			RemoveContextHookNative(context, hookToRemove);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RemoveContextHook(ref ImGuiContext context, uint hookToRemove)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				RemoveContextHookNative((ImGuiContext*)pcontext, hookToRemove);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CallContextHooksNative(ImGuiContext* context, ImGuiContextHookType type)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiContextHookType, void>)funcTable[1062])(context, type);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiContextHookType, void>)funcTable[1062])((nint)context, type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CallContextHooks(ImGuiContextPtr context, ImGuiContextHookType type)
		{
			CallContextHooksNative(context, type);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CallContextHooks(ref ImGuiContext context, ImGuiContextHookType type)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				CallContextHooksNative((ImGuiContext*)pcontext, type);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TranslateWindowsInViewportNative(ImGuiViewportP* viewport, Vector2 oldPos, Vector2 newPos, Vector2 oldSize, Vector2 newSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, Vector2, Vector2, Vector2, Vector2, void>)funcTable[1063])(viewport, oldPos, newPos, oldSize, newSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, void>)funcTable[1063])((nint)viewport, oldPos, newPos, oldSize, newSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateWindowsInViewport(ImGuiViewportPPtr viewport, Vector2 oldPos, Vector2 newPos, Vector2 oldSize, Vector2 newSize)
		{
			TranslateWindowsInViewportNative(viewport, oldPos, newPos, oldSize, newSize);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateWindowsInViewport(ref ImGuiViewportP viewport, Vector2 oldPos, Vector2 newPos, Vector2 oldSize, Vector2 newSize)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				TranslateWindowsInViewportNative((ImGuiViewportP*)pviewport, oldPos, newPos, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScaleWindowsInViewportNative(ImGuiViewportP* viewport, float scale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, float, void>)funcTable[1064])(viewport, scale);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[1064])((nint)viewport, scale);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScaleWindowsInViewport(ImGuiViewportPPtr viewport, float scale)
		{
			ScaleWindowsInViewportNative(viewport, scale);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScaleWindowsInViewport(ref ImGuiViewportP viewport, float scale)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ScaleWindowsInViewportNative((ImGuiViewportP*)pviewport, scale);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyPlatformWindowNative(ImGuiViewportP* viewport)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)funcTable[1065])(viewport);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1065])((nint)viewport);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DestroyPlatformWindow(ImGuiViewportPPtr viewport)
		{
			DestroyPlatformWindowNative(viewport);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DestroyPlatformWindow(ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				DestroyPlatformWindowNative((ImGuiViewportP*)pviewport);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowViewportNative(ImGuiWindow* window, ImGuiViewportP* viewport)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiViewportP*, void>)funcTable[1066])(window, viewport);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1066])((nint)window, (nint)viewport);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowViewport(ImGuiWindowPtr window, ImGuiViewportPPtr viewport)
		{
			SetWindowViewportNative(window, viewport);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowViewport(ref ImGuiWindow window, ImGuiViewportPPtr viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowViewportNative((ImGuiWindow*)pwindow, viewport);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowViewport(ImGuiWindowPtr window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				SetWindowViewportNative(window, (ImGuiViewportP*)pviewport);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					SetWindowViewportNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCurrentViewportNative(ImGuiWindow* window, ImGuiViewportP* viewport)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiViewportP*, void>)funcTable[1067])(window, viewport);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1067])((nint)window, (nint)viewport);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentViewport(ImGuiWindowPtr window, ImGuiViewportPPtr viewport)
		{
			SetCurrentViewportNative(window, viewport);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentViewport(ref ImGuiWindow window, ImGuiViewportPPtr viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetCurrentViewportNative((ImGuiWindow*)pwindow, viewport);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentViewport(ImGuiWindowPtr window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				SetCurrentViewportNative(window, (ImGuiViewportP*)pviewport);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCurrentViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					SetCurrentViewportNative((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPlatformMonitor* GetViewportPlatformMonitorNative(ImGuiViewport* viewport)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*, ImGuiPlatformMonitor*>)funcTable[1068])(viewport);
			#else
			return (ImGuiPlatformMonitor*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1068])((nint)viewport);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPlatformMonitorPtr GetViewportPlatformMonitor(ImGuiViewportPtr viewport)
		{
			ImGuiPlatformMonitorPtr ret = GetViewportPlatformMonitorNative(viewport);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPlatformMonitorPtr GetViewportPlatformMonitor(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImGuiPlatformMonitorPtr ret = GetViewportPlatformMonitorNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiViewportP* FindHoveredViewportFromPlatformWindowStackNative(Vector2 mousePlatformPos)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, ImGuiViewportP*>)funcTable[1069])(mousePlatformPos);
			#else
			return (ImGuiViewportP*)((delegate* unmanaged[Cdecl]<Vector2, nint>)funcTable[1069])(mousePlatformPos);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiViewportPPtr FindHoveredViewportFromPlatformWindowStack(Vector2 mousePlatformPos)
		{
			ImGuiViewportPPtr ret = FindHoveredViewportFromPlatformWindowStackNative(mousePlatformPos);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MarkIniSettingsDirtyNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1070])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1070])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MarkIniSettingsDirty()
		{
			MarkIniSettingsDirtyNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MarkIniSettingsDirtyNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1071])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1071])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MarkIniSettingsDirty(ImGuiWindowPtr window)
		{
			MarkIniSettingsDirtyNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MarkIniSettingsDirty(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				MarkIniSettingsDirtyNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearIniSettingsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1072])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1072])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearIniSettings()
		{
			ClearIniSettingsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddSettingsHandlerNative(ImGuiSettingsHandler* handler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiSettingsHandler*, void>)funcTable[1073])(handler);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1073])((nint)handler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddSettingsHandler(ImGuiSettingsHandlerPtr handler)
		{
			AddSettingsHandlerNative(handler);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddSettingsHandler(ref ImGuiSettingsHandler handler)
		{
			fixed (ImGuiSettingsHandler* phandler = &handler)
			{
				AddSettingsHandlerNative((ImGuiSettingsHandler*)phandler);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RemoveSettingsHandlerNative(byte* typeName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[1074])(typeName);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1074])((nint)typeName);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RemoveSettingsHandler(byte* typeName)
		{
			RemoveSettingsHandlerNative(typeName);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RemoveSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				RemoveSettingsHandlerNative((byte*)ptypeName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RemoveSettingsHandler(ReadOnlySpan<byte> typeName)
		{
			fixed (byte* ptypeName = typeName)
			{
				RemoveSettingsHandlerNative((byte*)ptypeName);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RemoveSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RemoveSettingsHandlerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiSettingsHandler* FindSettingsHandlerNative(byte* typeName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiSettingsHandler*>)funcTable[1075])(typeName);
			#else
			return (ImGuiSettingsHandler*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1075])((nint)typeName);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSettingsHandlerPtr FindSettingsHandler(byte* typeName)
		{
			ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative(typeName);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSettingsHandlerPtr FindSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative((byte*)ptypeName);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSettingsHandlerPtr FindSettingsHandler(ReadOnlySpan<byte> typeName)
		{
			fixed (byte* ptypeName = typeName)
			{
				ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative((byte*)ptypeName);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSettingsHandlerPtr FindSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiSettingsHandlerPtr ret = FindSettingsHandlerNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindowSettings* CreateNewWindowSettingsNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiWindowSettings*>)funcTable[1076])(name);
			#else
			return (ImGuiWindowSettings*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1076])((nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(byte* name)
		{
			ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative(name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowSettingsPtr ret = CreateNewWindowSettingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindowSettings* FindWindowSettingsByIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiWindowSettings*>)funcTable[1077])(id);
			#else
			return (ImGuiWindowSettings*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[1077])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr FindWindowSettingsByID(uint id)
		{
			ImGuiWindowSettingsPtr ret = FindWindowSettingsByIDNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindowSettings* FindWindowSettingsByWindowNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindowSettings*>)funcTable[1078])(window);
			#else
			return (ImGuiWindowSettings*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1078])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr FindWindowSettingsByWindow(ImGuiWindowPtr window)
		{
			ImGuiWindowSettingsPtr ret = FindWindowSettingsByWindowNative(window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr FindWindowSettingsByWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowSettingsPtr ret = FindWindowSettingsByWindowNative((ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearWindowSettingsNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[1079])(name);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1079])((nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearWindowSettings(byte* name)
		{
			ClearWindowSettingsNative(name);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ClearWindowSettingsNative((byte*)pname);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearWindowSettings(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ClearWindowSettingsNative((byte*)pname);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ClearWindowSettingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LocalizeRegisterEntriesNative(ImGuiLocEntry* entries, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiLocEntry*, int, void>)funcTable[1080])(entries, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[1080])((nint)entries, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LocalizeRegisterEntries(ImGuiLocEntryPtr entries, int count)
		{
			LocalizeRegisterEntriesNative(entries, count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LocalizeRegisterEntries(ref ImGuiLocEntry entries, int count)
		{
			fixed (ImGuiLocEntry* pentries = &entries)
			{
				LocalizeRegisterEntriesNative((ImGuiLocEntry*)pentries, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* LocalizeGetMsgNative(ImGuiLocKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiLocKey, byte*>)funcTable[1081])(key);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ImGuiLocKey, nint>)funcTable[1081])(key);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* LocalizeGetMsg(ImGuiLocKey key)
		{
			byte* ret = LocalizeGetMsgNative(key);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string LocalizeGetMsgS(ImGuiLocKey key)
		{
			string ret = Utils.DecodeStringUTF8(LocalizeGetMsgNative(key));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollXNative(ImGuiWindow* window, float scrollX)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, float, void>)funcTable[1082])(window, scrollX);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[1082])((nint)window, scrollX);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollX(ImGuiWindowPtr window, float scrollX)
		{
			SetScrollXNative(window, scrollX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollX(ref ImGuiWindow window, float scrollX)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollXNative((ImGuiWindow*)pwindow, scrollX);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollYNative(ImGuiWindow* window, float scrollY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, float, void>)funcTable[1083])(window, scrollY);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[1083])((nint)window, scrollY);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollY(ImGuiWindowPtr window, float scrollY)
		{
			SetScrollYNative(window, scrollY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollY(ref ImGuiWindow window, float scrollY)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollYNative((ImGuiWindow*)pwindow, scrollY);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollFromPosXNative(ImGuiWindow* window, float localX, float centerXRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, float, float, void>)funcTable[1084])(window, localX, centerXRatio);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, void>)funcTable[1084])((nint)window, localX, centerXRatio);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollFromPosX(ImGuiWindowPtr window, float localX, float centerXRatio)
		{
			SetScrollFromPosXNative(window, localX, centerXRatio);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollFromPosX(ref ImGuiWindow window, float localX, float centerXRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollFromPosXNative((ImGuiWindow*)pwindow, localX, centerXRatio);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScrollFromPosYNative(ImGuiWindow* window, float localY, float centerYRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, float, float, void>)funcTable[1085])(window, localY, centerYRatio);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, void>)funcTable[1085])((nint)window, localY, centerYRatio);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollFromPosY(ImGuiWindowPtr window, float localY, float centerYRatio)
		{
			SetScrollFromPosYNative(window, localY, centerYRatio);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScrollFromPosY(ref ImGuiWindow window, float localY, float centerYRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetScrollFromPosYNative((ImGuiWindow*)pwindow, localY, centerYRatio);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScrollToItemNative(ImGuiScrollFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiScrollFlags, void>)funcTable[1086])(flags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiScrollFlags, void>)funcTable[1086])(flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToItem(ImGuiScrollFlags flags)
		{
			ScrollToItemNative(flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToItem()
		{
			ScrollToItemNative((ImGuiScrollFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScrollToRectNative(ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImRect, ImGuiScrollFlags, void>)funcTable[1087])(window, rect, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, ImGuiScrollFlags, void>)funcTable[1087])((nint)window, rect, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRect(ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			ScrollToRectNative(window, rect, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRect(ImGuiWindowPtr window, ImRect rect)
		{
			ScrollToRectNative(window, rect, (ImGuiScrollFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRect(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRectNative((ImGuiWindow*)pwindow, rect, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRect(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRectNative((ImGuiWindow*)pwindow, rect, (ImGuiScrollFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScrollToRectExNative(Vector2* pOut, ImGuiWindow* window, ImRect rect, ImGuiScrollFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiWindow*, ImRect, ImGuiScrollFlags, void>)funcTable[1088])(pOut, window, rect, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, ImRect, ImGuiScrollFlags, void>)funcTable[1088])((nint)pOut, (nint)window, rect, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ScrollToRectEx(ImGuiWindowPtr window, ImRect rect)
		{
			Vector2 ret;
			ScrollToRectExNative(&ret, window, rect, (ImGuiScrollFlags)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ScrollToRectEx(ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			Vector2 ret;
			ScrollToRectExNative(&ret, window, rect, flags);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRectEx(Vector2* pOut, ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			ScrollToRectExNative(pOut, window, rect, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRectEx(Vector2* pOut, ImGuiWindowPtr window, ImRect rect)
		{
			ScrollToRectExNative(pOut, window, rect, (ImGuiScrollFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRectEx(ref Vector2 pOut, ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ScrollToRectExNative((Vector2*)ppOut, window, rect, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRectEx(ref Vector2 pOut, ImGuiWindowPtr window, ImRect rect)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ScrollToRectExNative((Vector2*)ppOut, window, rect, (ImGuiScrollFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ScrollToRectEx(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				ScrollToRectExNative(&ret, (ImGuiWindow*)pwindow, rect, (ImGuiScrollFlags)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ScrollToRectEx(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				ScrollToRectExNative(&ret, (ImGuiWindow*)pwindow, rect, flags);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRectEx(Vector2* pOut, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRectExNative(pOut, (ImGuiWindow*)pwindow, rect, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRectEx(Vector2* pOut, ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToRectExNative(pOut, (ImGuiWindow*)pwindow, rect, (ImGuiScrollFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRectEx(ref Vector2 pOut, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ScrollToRectExNative((Vector2*)ppOut, (ImGuiWindow*)pwindow, rect, flags);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToRectEx(ref Vector2 pOut, ref ImGuiWindow window, ImRect rect)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ScrollToRectExNative((Vector2*)ppOut, (ImGuiWindow*)pwindow, rect, (ImGuiScrollFlags)(0));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScrollToBringRectIntoViewNative(ImGuiWindow* window, ImRect rect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImRect, void>)funcTable[1089])(window, rect);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)funcTable[1089])((nint)window, rect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToBringRectIntoView(ImGuiWindowPtr window, ImRect rect)
		{
			ScrollToBringRectIntoViewNative(window, rect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ScrollToBringRectIntoView(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ScrollToBringRectIntoViewNative((ImGuiWindow*)pwindow, rect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiItemStatusFlags GetItemStatusFlagsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiItemStatusFlags>)funcTable[1090])();
			#else
			return (ImGuiItemStatusFlags)((delegate* unmanaged[Cdecl]<ImGuiItemStatusFlags>)funcTable[1090])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiItemStatusFlags GetItemStatusFlags()
		{
			ImGuiItemStatusFlags ret = GetItemStatusFlagsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiItemFlags GetItemFlagsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiItemFlags>)funcTable[1091])();
			#else
			return (ImGuiItemFlags)((delegate* unmanaged[Cdecl]<ImGuiItemFlags>)funcTable[1091])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiItemFlags GetItemFlags()
		{
			ImGuiItemFlags ret = GetItemFlagsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetActiveIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1092])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1092])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetActiveID()
		{
			uint ret = GetActiveIDNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetFocusIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1093])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1093])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetFocusID()
		{
			uint ret = GetFocusIDNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetActiveIDNative(uint id, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ImGuiWindow*, void>)funcTable[1094])(id, window);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[1094])(id, (nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetActiveID(uint id, ImGuiWindowPtr window)
		{
			SetActiveIDNative(id, window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetActiveID(uint id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetActiveIDNative(id, (ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFocusIDNative(uint id, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ImGuiWindow*, void>)funcTable[1095])(id, window);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[1095])(id, (nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetFocusID(uint id, ImGuiWindowPtr window)
		{
			SetFocusIDNative(id, window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetFocusID(uint id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetFocusIDNative(id, (ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearActiveIDNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1096])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1096])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearActiveID()
		{
			ClearActiveIDNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHoveredIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1097])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1097])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetHoveredID()
		{
			uint ret = GetHoveredIDNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetHoveredIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1098])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1098])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetHoveredID(uint id)
		{
			SetHoveredIDNative(id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void KeepAliveIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1099])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1099])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void KeepAliveID(uint id)
		{
			KeepAliveIDNative(id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MarkItemEditedNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1100])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1100])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MarkItemEdited(uint id)
		{
			MarkItemEditedNative(id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushOverrideIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1101])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1101])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushOverrideID(uint id)
		{
			PushOverrideIDNative(id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDWithSeedNative(byte* strIdBegin, byte* strIdEnd, uint seed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, uint, uint>)funcTable[1102])(strIdBegin, strIdEnd, seed);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint, uint>)funcTable[1102])((nint)strIdBegin, (nint)strIdEnd, seed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(byte* strIdBegin, byte* strIdEnd, uint seed)
		{
			uint ret = GetIDWithSeedNative(strIdBegin, strIdEnd, seed);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ref byte strIdBegin, byte* strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, strIdEnd, seed);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ReadOnlySpan<byte> strIdBegin, byte* strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, strIdEnd, seed);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(string strIdBegin, byte* strIdEnd, uint seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDWithSeedNative(pStr0, strIdEnd, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(byte* strIdBegin, ref byte strIdEnd, uint seed)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				uint ret = GetIDWithSeedNative(strIdBegin, (byte*)pstrIdEnd, seed);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(byte* strIdBegin, ReadOnlySpan<byte> strIdEnd, uint seed)
		{
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				uint ret = GetIDWithSeedNative(strIdBegin, (byte*)pstrIdEnd, seed);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(byte* strIdBegin, string strIdEnd, uint seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDWithSeedNative(strIdBegin, pStr0, seed);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ref byte strIdBegin, ref byte strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ReadOnlySpan<byte> strIdBegin, ReadOnlySpan<byte> strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(string strIdBegin, string strIdEnd, uint seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strIdEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strIdEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			uint ret = GetIDWithSeedNative(pStr0, pStr1, seed);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ref byte strIdBegin, ReadOnlySpan<byte> strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				fixed (byte* pstrIdEnd = strIdEnd)
				{
					uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ref byte strIdBegin, string strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = &strIdBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strIdEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, pStr0, seed);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ReadOnlySpan<byte> strIdBegin, ref byte strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				fixed (byte* pstrIdEnd = &strIdEnd)
				{
					uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, (byte*)pstrIdEnd, seed);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(ReadOnlySpan<byte> strIdBegin, string strIdEnd, uint seed)
		{
			fixed (byte* pstrIdBegin = strIdBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strIdEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDWithSeedNative((byte*)pstrIdBegin, pStr0, seed);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(string strIdBegin, ref byte strIdEnd, uint seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				uint ret = GetIDWithSeedNative(pStr0, (byte*)pstrIdEnd, seed);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(string strIdBegin, ReadOnlySpan<byte> strIdEnd, uint seed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrIdEnd = strIdEnd)
			{
				uint ret = GetIDWithSeedNative(pStr0, (byte*)pstrIdEnd, seed);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDWithSeedNative(int n, uint seed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint, uint>)funcTable[1103])(n, seed);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint, uint>)funcTable[1103])(n, seed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDWithSeed(int n, uint seed)
		{
			uint ret = GetIDWithSeedNative(n, seed);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ItemSizeNative(Vector2 size, float textBaselineY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, float, void>)funcTable[1104])(size, textBaselineY);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, float, void>)funcTable[1104])(size, textBaselineY);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemSize(Vector2 size, float textBaselineY)
		{
			ItemSizeNative(size, textBaselineY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemSize(Vector2 size)
		{
			ItemSizeNative(size, (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ItemSizeNative(ImRect bb, float textBaselineY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect, float, void>)funcTable[1105])(bb, textBaselineY);
			#else
			((delegate* unmanaged[Cdecl]<ImRect, float, void>)funcTable[1105])(bb, textBaselineY);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemSize(ImRect bb, float textBaselineY)
		{
			ItemSizeNative(bb, textBaselineY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ItemSize(ImRect bb)
		{
			ItemSizeNative(bb, (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ItemAddNative(ImRect bb, uint id, ImRect* navBb, ImGuiItemFlags extraFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, uint, ImRect*, ImGuiItemFlags, byte>)funcTable[1106])(bb, id, navBb, extraFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, uint, nint, ImGuiItemFlags, byte>)funcTable[1106])(bb, id, (nint)navBb, extraFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ImRectPtr navBb, ImGuiItemFlags extraFlags)
		{
			byte ret = ItemAddNative(bb, id, navBb, extraFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ImRectPtr navBb)
		{
			byte ret = ItemAddNative(bb, id, navBb, (ImGuiItemFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id)
		{
			byte ret = ItemAddNative(bb, id, (ImRect*)(default), (ImGuiItemFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ImGuiItemFlags extraFlags)
		{
			byte ret = ItemAddNative(bb, id, (ImRect*)(default), extraFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ref ImRect navBb, ImGuiItemFlags extraFlags)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				byte ret = ItemAddNative(bb, id, (ImRect*)pnavBb, extraFlags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemAdd(ImRect bb, uint id, ref ImRect navBb)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				byte ret = ItemAddNative(bb, id, (ImRect*)pnavBb, (ImGuiItemFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ItemHoverableNative(ImRect bb, uint id, ImGuiItemFlags itemFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, uint, ImGuiItemFlags, byte>)funcTable[1107])(bb, id, itemFlags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, uint, ImGuiItemFlags, byte>)funcTable[1107])(bb, id, itemFlags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ItemHoverable(ImRect bb, uint id, ImGuiItemFlags itemFlags)
		{
			byte ret = ItemHoverableNative(bb, id, itemFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowContentHoverableNative(ImGuiWindow* window, ImGuiHoveredFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiHoveredFlags, byte>)funcTable[1108])(window, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiHoveredFlags, byte>)funcTable[1108])((nint)window, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowContentHoverable(ImGuiWindowPtr window, ImGuiHoveredFlags flags)
		{
			byte ret = IsWindowContentHoverableNative(window, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowContentHoverable(ImGuiWindowPtr window)
		{
			byte ret = IsWindowContentHoverableNative(window, (ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowContentHoverable(ref ImGuiWindow window, ImGuiHoveredFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowContentHoverableNative((ImGuiWindow*)pwindow, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowContentHoverable(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowContentHoverableNative((ImGuiWindow*)pwindow, (ImGuiHoveredFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsClippedExNative(ImRect bb, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect, uint, byte>)funcTable[1109])(bb, id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImRect, uint, byte>)funcTable[1109])(bb, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsClippedEx(ImRect bb, uint id)
		{
			byte ret = IsClippedExNative(bb, id);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetLastItemDataNative(uint itemId, ImGuiItemFlags itemFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ImGuiItemFlags, ImGuiItemStatusFlags, ImRect, void>)funcTable[1110])(itemId, itemFlags, statusFlags, itemRect);
			#else
			((delegate* unmanaged[Cdecl]<uint, ImGuiItemFlags, ImGuiItemStatusFlags, ImRect, void>)funcTable[1110])(itemId, itemFlags, statusFlags, itemRect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetLastItemData(uint itemId, ImGuiItemFlags itemFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect)
		{
			SetLastItemDataNative(itemId, itemFlags, statusFlags, itemRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcItemSizeNative(Vector2* pOut, Vector2 size, float defaultW, float defaultH)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, float, float, void>)funcTable[1111])(pOut, size, defaultW, defaultH);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, float, float, void>)funcTable[1111])((nint)pOut, size, defaultW, defaultH);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcItemSize(Vector2 size, float defaultW, float defaultH)
		{
			Vector2 ret;
			CalcItemSizeNative(&ret, size, defaultW, defaultH);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcItemSize(Vector2* pOut, Vector2 size, float defaultW, float defaultH)
		{
			CalcItemSizeNative(pOut, size, defaultW, defaultH);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcItemSize(ref Vector2 pOut, Vector2 size, float defaultW, float defaultH)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcItemSizeNative((Vector2*)ppOut, size, defaultW, defaultH);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CalcWrapWidthForPosNative(Vector2 pos, float wrapPosX)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, float, float>)funcTable[1112])(pos, wrapPosX);
			#else
			return (float)((delegate* unmanaged[Cdecl]<Vector2, float, float>)funcTable[1112])(pos, wrapPosX);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float CalcWrapWidthForPos(Vector2 pos, float wrapPosX)
		{
			float ret = CalcWrapWidthForPosNative(pos, wrapPosX);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushMultiItemsWidthsNative(int components, float widthFull)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[1113])(components, widthFull);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[1113])(components, widthFull);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushMultiItemsWidths(int components, float widthFull)
		{
			PushMultiItemsWidthsNative(components, widthFull);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShrinkWidthsNative(ImGuiShrinkWidthItem* items, int count, float widthExcess)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiShrinkWidthItem*, int, float, void>)funcTable[1114])(items, count, widthExcess);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, void>)funcTable[1114])((nint)items, count, widthExcess);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShrinkWidths(ImGuiShrinkWidthItemPtr items, int count, float widthExcess)
		{
			ShrinkWidthsNative(items, count, widthExcess);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ShrinkWidths(ref ImGuiShrinkWidthItem items, int count, float widthExcess)
		{
			fixed (ImGuiShrinkWidthItem* pitems = &items)
			{
				ShrinkWidthsNative((ImGuiShrinkWidthItem*)pitems, count, widthExcess);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyleVarInfo* GetStyleVarInfoNative(ImGuiStyleVar idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, ImGuiStyleVarInfo*>)funcTable[1115])(idx);
			#else
			return (ImGuiStyleVarInfo*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, nint>)funcTable[1115])(idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleVarInfoPtr GetStyleVarInfo(ImGuiStyleVar idx)
		{
			ImGuiStyleVarInfoPtr ret = GetStyleVarInfoNative(idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginDisabledOverrideReenableNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1116])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1116])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BeginDisabledOverrideReenable()
		{
			BeginDisabledOverrideReenableNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndDisabledOverrideReenableNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1117])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1117])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void EndDisabledOverrideReenable()
		{
			EndDisabledOverrideReenableNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogBeginNative(ImGuiLogFlags flags, int autoOpenDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiLogFlags, int, void>)funcTable[1118])(flags, autoOpenDepth);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiLogFlags, int, void>)funcTable[1118])(flags, autoOpenDepth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogBegin(ImGuiLogFlags flags, int autoOpenDepth)
		{
			LogBeginNative(flags, autoOpenDepth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogToBufferNative(int autoOpenDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1119])(autoOpenDepth);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[1119])(autoOpenDepth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogToBuffer(int autoOpenDepth)
		{
			LogToBufferNative(autoOpenDepth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogToBuffer()
		{
			LogToBufferNative((int)(-1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogRenderedTextNative(Vector2* refPos, byte* text, byte* textEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, byte*, byte*, void>)funcTable[1120])(refPos, text, textEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1120])((nint)refPos, (nint)text, (nint)textEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text, byte* textEnd)
		{
			LogRenderedTextNative(refPos, text, textEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text)
		{
			LogRenderedTextNative(refPos, text, (byte*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				LogRenderedTextNative((Vector2*)prefPos, text, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				LogRenderedTextNative((Vector2*)prefPos, text, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (byte* ptext = text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				LogRenderedTextNative(refPos, (byte*)ptext, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ref byte text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ref byte text)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ReadOnlySpan<byte> text)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = text)
				{
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, string text, byte* textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, string text)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				LogRenderedTextNative(refPos, text, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				LogRenderedTextNative(refPos, text, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogRenderedTextNative(refPos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative((Vector2*)prefPos, text, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					LogRenderedTextNative((Vector2*)prefPos, text, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, byte* text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					LogRenderedTextNative(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			LogRenderedTextNative(refPos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ref byte text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					LogRenderedTextNative(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ref byte text, string textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative(refPos, (byte*)ptext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ReadOnlySpan<byte> text, ref byte textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative(refPos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, ReadOnlySpan<byte> text, string textEnd)
		{
			fixed (byte* ptext = text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				LogRenderedTextNative(refPos, (byte*)ptext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, string text, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				LogRenderedTextNative(refPos, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(Vector2* refPos, string text, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				LogRenderedTextNative(refPos, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ref byte text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, string text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				LogRenderedTextNative((Vector2*)prefPos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ref byte text, ReadOnlySpan<byte> textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ref byte text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = &text)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ReadOnlySpan<byte> text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, ReadOnlySpan<byte> text, string textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				fixed (byte* ptext = text)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					LogRenderedTextNative((Vector2*)prefPos, (byte*)ptext, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void LogRenderedText(ref Vector2 refPos, string text, ref byte textEnd)
		{
			fixed (Vector2* prefPos = &refPos)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					LogRenderedTextNative((Vector2*)prefPos, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}
	}
}
