// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGuiP
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImRotate(ref Vector2 pOut, Vector2 v, float cosA, float sinA)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImRotateNative((Vector2*)ppOut, v, cosA, sinA);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImLinearSweepNative(float current, float target, float speed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float>)funcTable[784])(current, target, speed);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float, float>)funcTable[784])(current, target, speed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImLinearSweep(float current, float target, float speed)
		{
			float ret = ImLinearSweepNative(current, target, speed);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImLinearRemapClampNative(float s0, float s1, float d0, float d1, float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, float, float>)funcTable[785])(s0, s1, d0, d1, x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float, float, float, float>)funcTable[785])(s0, s1, d0, d1, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImLinearRemapClamp(float s0, float s1, float d0, float d1, float x)
		{
			float ret = ImLinearRemapClampNative(s0, s1, d0, d1, x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImMulNative(Vector2* pOut, Vector2 lhs, Vector2 rhs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, void>)funcTable[786])(pOut, lhs, rhs);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, void>)funcTable[786])((nint)pOut, lhs, rhs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ImMul(Vector2 lhs, Vector2 rhs)
		{
			Vector2 ret;
			ImMulNative(&ret, lhs, rhs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMul(Vector2* pOut, Vector2 lhs, Vector2 rhs)
		{
			ImMulNative(pOut, lhs, rhs);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImMul(ref Vector2 pOut, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImMulNative((Vector2*)ppOut, lhs, rhs);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImIsFloatAboveGuaranteedIntegerPrecisionNative(float f)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, byte>)funcTable[787])(f);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<float, byte>)funcTable[787])(f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImIsFloatAboveGuaranteedIntegerPrecision(float f)
		{
			byte ret = ImIsFloatAboveGuaranteedIntegerPrecisionNative(f);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImExponentialMovingAverageNative(float avg, float sample, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, int, float>)funcTable[788])(avg, sample, n);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, int, float>)funcTable[788])(avg, sample, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImExponentialMovingAverage(float avg, float sample, int n)
		{
			float ret = ImExponentialMovingAverageNative(avg, sample, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBezierCubicCalcNative(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, Vector2, float, void>)funcTable[789])(pOut, p1, p2, p3, p4, t);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, float, void>)funcTable[789])((nint)pOut, p1, p2, p3, p4, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ImBezierCubicCalc(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			Vector2 ret;
			ImBezierCubicCalcNative(&ret, p1, p2, p3, p4, t);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBezierCubicCalc(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			ImBezierCubicCalcNative(pOut, p1, p2, p3, p4, t);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBezierCubicCalc(ref Vector2 pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImBezierCubicCalcNative((Vector2*)ppOut, p1, p2, p3, p4, t);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBezierCubicClosestPointNative(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, Vector2, Vector2, int, void>)funcTable[790])(pOut, p1, p2, p3, p4, p, numSegments);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, Vector2, int, void>)funcTable[790])((nint)pOut, p1, p2, p3, p4, p, numSegments);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ImBezierCubicClosestPoint(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			Vector2 ret;
			ImBezierCubicClosestPointNative(&ret, p1, p2, p3, p4, p, numSegments);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBezierCubicClosestPoint(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			ImBezierCubicClosestPointNative(pOut, p1, p2, p3, p4, p, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBezierCubicClosestPoint(ref Vector2 pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImBezierCubicClosestPointNative((Vector2*)ppOut, p1, p2, p3, p4, p, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBezierCubicClosestPointCasteljauNative(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, Vector2, Vector2, float, void>)funcTable[791])(pOut, p1, p2, p3, p4, p, tessTol);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, Vector2, float, void>)funcTable[791])((nint)pOut, p1, p2, p3, p4, p, tessTol);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ImBezierCubicClosestPointCasteljau(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			Vector2 ret;
			ImBezierCubicClosestPointCasteljauNative(&ret, p1, p2, p3, p4, p, tessTol);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBezierCubicClosestPointCasteljau(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			ImBezierCubicClosestPointCasteljauNative(pOut, p1, p2, p3, p4, p, tessTol);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBezierCubicClosestPointCasteljau(ref Vector2 pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImBezierCubicClosestPointCasteljauNative((Vector2*)ppOut, p1, p2, p3, p4, p, tessTol);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBezierQuadraticCalcNative(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, float, void>)funcTable[792])(pOut, p1, p2, p3, t);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, float, void>)funcTable[792])((nint)pOut, p1, p2, p3, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ImBezierQuadraticCalc(Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			Vector2 ret;
			ImBezierQuadraticCalcNative(&ret, p1, p2, p3, t);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBezierQuadraticCalc(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			ImBezierQuadraticCalcNative(pOut, p1, p2, p3, t);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBezierQuadraticCalc(ref Vector2 pOut, Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImBezierQuadraticCalcNative((Vector2*)ppOut, p1, p2, p3, t);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImLineClosestPointNative(Vector2* pOut, Vector2 a, Vector2 b, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, void>)funcTable[793])(pOut, a, b, p);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, void>)funcTable[793])((nint)pOut, a, b, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ImLineClosestPoint(Vector2 a, Vector2 b, Vector2 p)
		{
			Vector2 ret;
			ImLineClosestPointNative(&ret, a, b, p);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImLineClosestPoint(Vector2* pOut, Vector2 a, Vector2 b, Vector2 p)
		{
			ImLineClosestPointNative(pOut, a, b, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImLineClosestPoint(ref Vector2 pOut, Vector2 a, Vector2 b, Vector2 p)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImLineClosestPointNative((Vector2*)ppOut, a, b, p);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImTriangleContainsPointNative(Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, byte>)funcTable[794])(a, b, c, p);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, byte>)funcTable[794])(a, b, c, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImTriangleContainsPoint(Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			byte ret = ImTriangleContainsPointNative(a, b, c, p);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImTriangleClosestPointNative(Vector2* pOut, Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, Vector2, void>)funcTable[795])(pOut, a, b, c, p);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, void>)funcTable[795])((nint)pOut, a, b, c, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ImTriangleClosestPoint(Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			Vector2 ret;
			ImTriangleClosestPointNative(&ret, a, b, c, p);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleClosestPoint(Vector2* pOut, Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			ImTriangleClosestPointNative(pOut, a, b, c, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleClosestPoint(ref Vector2 pOut, Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImTriangleClosestPointNative((Vector2*)ppOut, a, b, c, p);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImTriangleBarycentricCoordsNative(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, float* outW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, float*, float*, float*, void>)funcTable[796])(a, b, c, p, outU, outV, outW);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, nint, nint, nint, void>)funcTable[796])(a, b, c, p, (nint)outU, (nint)outV, (nint)outW);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, float* outW)
		{
			ImTriangleBarycentricCoordsNative(a, b, c, p, outU, outV, outW);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, float* outV, float* outW)
		{
			fixed (float* poutU = &outU)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, outV, outW);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, ref float outV, float* outW)
		{
			fixed (float* poutV = &outV)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, outU, (float*)poutV, outW);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, ref float outV, float* outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, (float*)poutV, outW);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, ref float outW)
		{
			fixed (float* poutW = &outW)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, outU, outV, (float*)poutW);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, float* outV, ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutW = &outW)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, outV, (float*)poutW);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, ref float outV, ref float outW)
		{
			fixed (float* poutV = &outV)
			{
				fixed (float* poutW = &outW)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, outU, (float*)poutV, (float*)poutW);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, ref float outV, ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					fixed (float* poutW = &outW)
					{
						ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, (float*)poutV, (float*)poutW);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ImTriangleAreaNative(Vector2 a, Vector2 b, Vector2 c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, float>)funcTable[797])(a, b, c);
			#else
			return (float)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, float>)funcTable[797])(a, b, c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ImTriangleArea(Vector2 a, Vector2 b, Vector2 c)
		{
			float ret = ImTriangleAreaNative(a, b, c);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImTriangleIsClockwiseNative(Vector2 a, Vector2 b, Vector2 c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, byte>)funcTable[798])(a, b, c);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, byte>)funcTable[798])(a, b, c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImTriangleIsClockwise(Vector2 a, Vector2 b, Vector2 c)
		{
			byte ret = ImTriangleIsClockwiseNative(a, b, c);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImVec1* ImVec1Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImVec1*>)funcTable[799])();
			#else
			return (ImVec1*)((delegate* unmanaged[Cdecl]<nint>)funcTable[799])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImVec1Ptr ImVec1()
		{
			ImVec1Ptr ret = ImVec1Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImVec1* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVec1*, void>)funcTable[800])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[800])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImVec1Ptr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImVec1 self)
		{
			fixed (ImVec1* pself = &self)
			{
				DestroyNative((ImVec1*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImVec1* ImVec1Native(float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, ImVec1*>)funcTable[801])(x);
			#else
			return (ImVec1*)((delegate* unmanaged[Cdecl]<float, nint>)funcTable[801])(x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImVec1Ptr ImVec1(float x)
		{
			ImVec1Ptr ret = ImVec1Native(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImVec2I* ImVec2iNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImVec2I*>)funcTable[802])();
			#else
			return (ImVec2I*)((delegate* unmanaged[Cdecl]<nint>)funcTable[802])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImVec2IPtr ImVec2i()
		{
			ImVec2IPtr ret = ImVec2iNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImVec2I* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVec2I*, void>)funcTable[803])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[803])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImVec2IPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImVec2I self)
		{
			fixed (ImVec2I* pself = &self)
			{
				DestroyNative((ImVec2I*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImVec2I* ImVec2iNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, ImVec2I*>)funcTable[804])(x, y);
			#else
			return (ImVec2I*)((delegate* unmanaged[Cdecl]<int, int, nint>)funcTable[804])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImVec2IPtr ImVec2i(int x, int y)
		{
			ImVec2IPtr ret = ImVec2iNative(x, y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImVec2Ih* ImVec2ihNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImVec2Ih*>)funcTable[805])();
			#else
			return (ImVec2Ih*)((delegate* unmanaged[Cdecl]<nint>)funcTable[805])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImVec2IhPtr ImVec2ih()
		{
			ImVec2IhPtr ret = ImVec2ihNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImVec2Ih* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVec2Ih*, void>)funcTable[806])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[806])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImVec2IhPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImVec2Ih self)
		{
			fixed (ImVec2Ih* pself = &self)
			{
				DestroyNative((ImVec2Ih*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImVec2Ih* ImVec2ihNative(short x, short y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short, short, ImVec2Ih*>)funcTable[807])(x, y);
			#else
			return (ImVec2Ih*)((delegate* unmanaged[Cdecl]<short, short, nint>)funcTable[807])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImVec2IhPtr ImVec2ih(short x, short y)
		{
			ImVec2IhPtr ret = ImVec2ihNative(x, y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImVec2Ih* ImVec2ihNative(Vector2 rhs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, ImVec2Ih*>)funcTable[808])(rhs);
			#else
			return (ImVec2Ih*)((delegate* unmanaged[Cdecl]<Vector2, nint>)funcTable[808])(rhs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImVec2IhPtr ImVec2ih(Vector2 rhs)
		{
			ImVec2IhPtr ret = ImVec2ihNative(rhs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImRect* ImRectNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*>)funcTable[809])();
			#else
			return (ImRect*)((delegate* unmanaged[Cdecl]<nint>)funcTable[809])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRectPtr ImRect()
		{
			ImRectPtr ret = ImRectNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, void>)funcTable[810])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[810])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImRectPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				DestroyNative((ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImRect* ImRectNative(Vector2 min, Vector2 max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, ImRect*>)funcTable[811])(min, max);
			#else
			return (ImRect*)((delegate* unmanaged[Cdecl]<Vector2, Vector2, nint>)funcTable[811])(min, max);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRectPtr ImRect(Vector2 min, Vector2 max)
		{
			ImRectPtr ret = ImRectNative(min, max);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImRect* ImRectNative(Vector4 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, ImRect*>)funcTable[812])(v);
			#else
			return (ImRect*)((delegate* unmanaged[Cdecl]<Vector4, nint>)funcTable[812])(v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRectPtr ImRect(Vector4 v)
		{
			ImRectPtr ret = ImRectNative(v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImRect* ImRectNative(float x1, float y1, float x2, float y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, ImRect*>)funcTable[813])(x1, y1, x2, y2);
			#else
			return (ImRect*)((delegate* unmanaged[Cdecl]<float, float, float, float, nint>)funcTable[813])(x1, y1, x2, y2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRectPtr ImRect(float x1, float y1, float x2, float y2)
		{
			ImRectPtr ret = ImRectNative(x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCenterNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)funcTable[814])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[814])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetCenter(ImRectPtr self)
		{
			Vector2 ret;
			GetCenterNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCenter(Vector2* pOut, ImRectPtr self)
		{
			GetCenterNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCenter(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetCenterNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetCenter(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetCenterNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCenter(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetCenterNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetCenter(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetCenterNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSizeNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)funcTable[815])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[815])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetSize(ImRectPtr self)
		{
			Vector2 ret;
			GetSizeNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetSize(Vector2* pOut, ImRectPtr self)
		{
			GetSizeNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetSize(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetSizeNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetSize(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetSizeNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetSize(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetSizeNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetSize(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetSizeNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWidthNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, float>)funcTable[816])(self);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[816])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetWidth(ImRectPtr self)
		{
			float ret = GetWidthNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetWidth(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = GetWidthNative((ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetHeightNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, float>)funcTable[817])(self);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[817])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetHeight(ImRectPtr self)
		{
			float ret = GetHeightNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetHeight(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = GetHeightNative((ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetAreaNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, float>)funcTable[818])(self);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[818])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetArea(ImRectPtr self)
		{
			float ret = GetAreaNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetArea(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = GetAreaNative((ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTLNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)funcTable[819])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[819])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetTL(ImRectPtr self)
		{
			Vector2 ret;
			GetTLNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetTL(Vector2* pOut, ImRectPtr self)
		{
			GetTLNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetTL(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetTLNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetTL(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetTLNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetTL(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetTLNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetTL(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetTLNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTRNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)funcTable[820])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[820])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetTR(ImRectPtr self)
		{
			Vector2 ret;
			GetTRNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetTR(Vector2* pOut, ImRectPtr self)
		{
			GetTRNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetTR(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetTRNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetTR(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetTRNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetTR(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetTRNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetTR(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetTRNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBLNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)funcTable[821])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[821])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetBL(ImRectPtr self)
		{
			Vector2 ret;
			GetBLNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBL(Vector2* pOut, ImRectPtr self)
		{
			GetBLNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBL(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetBLNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetBL(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetBLNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBL(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetBLNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBL(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetBLNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBRNative(Vector2* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImRect*, void>)funcTable[822])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[822])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetBR(ImRectPtr self)
		{
			Vector2 ret;
			GetBRNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBR(Vector2* pOut, ImRectPtr self)
		{
			GetBRNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBR(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetBRNative((Vector2*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 GetBR(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				GetBRNative(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBR(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				GetBRNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBR(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					GetBRNative((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ContainsNative(ImRect* self, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, Vector2, byte>)funcTable[823])(self, p);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, byte>)funcTable[823])((nint)self, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Contains(ImRectPtr self, Vector2 p)
		{
			byte ret = ContainsNative(self, p);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Contains(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ContainsNative((ImRect*)pself, p);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ContainsNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, ImRect, byte>)funcTable[824])(self, r);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImRect, byte>)funcTable[824])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Contains(ImRectPtr self, ImRect r)
		{
			byte ret = ContainsNative(self, r);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Contains(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ContainsNative((ImRect*)pself, r);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ContainsWithPadNative(ImRect* self, Vector2 p, Vector2 pad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, Vector2, Vector2, byte>)funcTable[825])(self, p, pad);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, byte>)funcTable[825])((nint)self, p, pad);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ContainsWithPad(ImRectPtr self, Vector2 p, Vector2 pad)
		{
			byte ret = ContainsWithPadNative(self, p, pad);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ContainsWithPad(ref ImRect self, Vector2 p, Vector2 pad)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ContainsWithPadNative((ImRect*)pself, p, pad);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte OverlapsNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, ImRect, byte>)funcTable[826])(self, r);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImRect, byte>)funcTable[826])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Overlaps(ImRectPtr self, ImRect r)
		{
			byte ret = OverlapsNative(self, r);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Overlaps(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = OverlapsNative((ImRect*)pself, r);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddNative(ImRect* self, Vector2 p)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, Vector2, void>)funcTable[827])(self, p);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, void>)funcTable[827])((nint)self, p);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Add(ImRectPtr self, Vector2 p)
		{
			AddNative(self, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Add(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				AddNative((ImRect*)pself, p);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImRect, void>)funcTable[828])(self, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)funcTable[828])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Add(ImRectPtr self, ImRect r)
		{
			AddNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Add(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				AddNative((ImRect*)pself, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ExpandNative(ImRect* self, float amount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, float, void>)funcTable[829])(self, amount);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[829])((nint)self, amount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Expand(ImRectPtr self, float amount)
		{
			ExpandNative(self, amount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Expand(ref ImRect self, float amount)
		{
			fixed (ImRect* pself = &self)
			{
				ExpandNative((ImRect*)pself, amount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ExpandNative(ImRect* self, Vector2 amount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, Vector2, void>)funcTable[830])(self, amount);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, void>)funcTable[830])((nint)self, amount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Expand(ImRectPtr self, Vector2 amount)
		{
			ExpandNative(self, amount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Expand(ref ImRect self, Vector2 amount)
		{
			fixed (ImRect* pself = &self)
			{
				ExpandNative((ImRect*)pself, amount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TranslateNative(ImRect* self, Vector2 d)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, Vector2, void>)funcTable[831])(self, d);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, void>)funcTable[831])((nint)self, d);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Translate(ImRectPtr self, Vector2 d)
		{
			TranslateNative(self, d);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Translate(ref ImRect self, Vector2 d)
		{
			fixed (ImRect* pself = &self)
			{
				TranslateNative((ImRect*)pself, d);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TranslateXNative(ImRect* self, float dx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, float, void>)funcTable[832])(self, dx);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[832])((nint)self, dx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateX(ImRectPtr self, float dx)
		{
			TranslateXNative(self, dx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateX(ref ImRect self, float dx)
		{
			fixed (ImRect* pself = &self)
			{
				TranslateXNative((ImRect*)pself, dx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TranslateYNative(ImRect* self, float dy)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, float, void>)funcTable[833])(self, dy);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[833])((nint)self, dy);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateY(ImRectPtr self, float dy)
		{
			TranslateYNative(self, dy);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TranslateY(ref ImRect self, float dy)
		{
			fixed (ImRect* pself = &self)
			{
				TranslateYNative((ImRect*)pself, dy);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipWithNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImRect, void>)funcTable[834])(self, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)funcTable[834])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClipWith(ImRectPtr self, ImRect r)
		{
			ClipWithNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClipWith(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ClipWithNative((ImRect*)pself, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipWithFullNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImRect, void>)funcTable[835])(self, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)funcTable[835])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClipWithFull(ImRectPtr self, ImRect r)
		{
			ClipWithFullNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClipWithFull(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ClipWithFullNative((ImRect*)pself, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FloorNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, void>)funcTable[836])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[836])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Floor(ImRectPtr self)
		{
			FloorNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Floor(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				FloorNative((ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsInvertedNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, byte>)funcTable[837])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[837])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInverted(ImRectPtr self)
		{
			byte ret = IsInvertedNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInverted(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = IsInvertedNative((ImRect*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ToVec4Native(Vector4* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, ImRect*, void>)funcTable[838])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[838])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 ToVec4(ImRectPtr self)
		{
			Vector4 ret;
			ToVec4Native(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(Vector4* pOut, ImRectPtr self)
		{
			ToVec4Native(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(ref Vector4 pOut, ImRectPtr self)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				ToVec4Native((Vector4*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 ToVec4(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector4 ret;
				ToVec4Native(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(Vector4* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ToVec4Native(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(ref Vector4 pOut, ref ImRect self)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ToVec4Native((Vector4*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint ImBitArrayGetStorageSizeInBytesNative(int bitcount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, nuint>)funcTable[839])(bitcount);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<int, nuint>)funcTable[839])(bitcount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint ImBitArrayGetStorageSizeInBytes(int bitcount)
		{
			nuint ret = ImBitArrayGetStorageSizeInBytesNative(bitcount);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBitArrayClearAllBitsNative(uint* arr, int bitcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, void>)funcTable[840])(arr, bitcount);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[840])((nint)arr, bitcount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArrayClearAllBits(uint* arr, int bitcount)
		{
			ImBitArrayClearAllBitsNative(arr, bitcount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImBitArrayTestBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, byte>)funcTable[841])(arr, n);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[841])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImBitArrayTestBit(uint* arr, int n)
		{
			byte ret = ImBitArrayTestBitNative(arr, n);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBitArrayClearBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, void>)funcTable[842])(arr, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[842])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArrayClearBit(uint* arr, int n)
		{
			ImBitArrayClearBitNative(arr, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBitArraySetBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, void>)funcTable[843])(arr, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[843])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArraySetBit(uint* arr, int n)
		{
			ImBitArraySetBitNative(arr, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBitArraySetBitRangeNative(uint* arr, int n, int n2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, int, void>)funcTable[844])(arr, n, n2);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[844])((nint)arr, n, n2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArraySetBitRange(uint* arr, int n, int n2)
		{
			ImBitArraySetBitRangeNative(arr, n, n2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateNative(ImBitVector* self, int sz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)funcTable[845])(self, sz);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[845])((nint)self, sz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Create(ImBitVectorPtr self, int sz)
		{
			CreateNative(self, sz);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Create(ref ImBitVector self, int sz)
		{
			fixed (ImBitVector* pself = &self)
			{
				CreateNative((ImBitVector*)pself, sz);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(ImBitVector* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, void>)funcTable[846])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[846])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImBitVectorPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImBitVector self)
		{
			fixed (ImBitVector* pself = &self)
			{
				ClearNative((ImBitVector*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImBitVector*, int, byte>)funcTable[847])(self, n);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[847])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TestBit(ImBitVectorPtr self, int n)
		{
			byte ret = TestBitNative(self, n);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TestBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				byte ret = TestBitNative((ImBitVector*)pself, n);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)funcTable[848])(self, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[848])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetBit(ImBitVectorPtr self, int n)
		{
			SetBitNative(self, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				SetBitNative((ImBitVector*)pself, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)funcTable[849])(self, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[849])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearBit(ImBitVectorPtr self, int n)
		{
			ClearBitNative(self, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ClearBitNative((ImBitVector*)pself, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void clearNative(ImGuiTextIndex* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, void>)funcTable[850])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[850])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void clear(ImGuiTextIndexPtr self)
		{
			clearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void clear(ref ImGuiTextIndex self)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				clearNative((ImGuiTextIndex*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int sizeNative(ImGuiTextIndex* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, int>)funcTable[851])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[851])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int size(ImGuiTextIndexPtr self)
		{
			int ret = sizeNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int size(ref ImGuiTextIndex self)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				int ret = sizeNative((ImGuiTextIndex*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* get_line_beginNative(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, byte*, int, byte*>)funcTable[852])(self, baseValue, n);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)funcTable[852])((nint)self, (nint)baseValue, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ImGuiTextIndexPtr self, byte* baseValue, int n)
		{
			byte* ret = get_line_beginNative(self, baseValue, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ImGuiTextIndexPtr self, byte* baseValue, int n)
		{
			string ret = Utils.DecodeStringUTF8(get_line_beginNative(self, baseValue, n));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* ret = get_line_beginNative((ImGuiTextIndex*)pself, baseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(get_line_beginNative((ImGuiTextIndex*)pself, baseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ImGuiTextIndexPtr self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = get_line_beginNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ImGuiTextIndexPtr self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(get_line_beginNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				byte* ret = get_line_beginNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				string ret = Utils.DecodeStringUTF8(get_line_beginNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = get_line_beginNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(get_line_beginNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = get_line_beginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(get_line_beginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					byte* ret = get_line_beginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					string ret = Utils.DecodeStringUTF8(get_line_beginNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_begin(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = get_line_beginNative((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_beginS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(get_line_beginNative((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* get_line_endNative(ImGuiTextIndex* self, byte* baseValue, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, byte*, int, byte*>)funcTable[853])(self, baseValue, n);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)funcTable[853])((nint)self, (nint)baseValue, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ImGuiTextIndexPtr self, byte* baseValue, int n)
		{
			byte* ret = get_line_endNative(self, baseValue, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ImGuiTextIndexPtr self, byte* baseValue, int n)
		{
			string ret = Utils.DecodeStringUTF8(get_line_endNative(self, baseValue, n));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* ret = get_line_endNative((ImGuiTextIndex*)pself, baseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ref ImGuiTextIndex self, byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(get_line_endNative((ImGuiTextIndex*)pself, baseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ImGuiTextIndexPtr self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = get_line_endNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ImGuiTextIndexPtr self, ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(get_line_endNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				byte* ret = get_line_endNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				string ret = Utils.DecodeStringUTF8(get_line_endNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = get_line_endNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ImGuiTextIndexPtr self, string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(get_line_endNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = get_line_endNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ref ImGuiTextIndex self, ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(get_line_endNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					byte* ret = get_line_endNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					string ret = Utils.DecodeStringUTF8(get_line_endNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* get_line_end(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = get_line_endNative((ImGuiTextIndex*)pself, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string get_line_endS(ref ImGuiTextIndex self, string baseValue, int n)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(get_line_endNative((ImGuiTextIndex*)pself, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void appendNative(ImGuiTextIndex* self, byte* baseValue, int oldSize, int newSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTextIndex*, byte*, int, int, void>)funcTable[854])(self, baseValue, oldSize, newSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)funcTable[854])((nint)self, (nint)baseValue, oldSize, newSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ImGuiTextIndexPtr self, byte* baseValue, int oldSize, int newSize)
		{
			appendNative(self, baseValue, oldSize, newSize);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ref ImGuiTextIndex self, byte* baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				appendNative((ImGuiTextIndex*)pself, baseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ImGuiTextIndexPtr self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				appendNative(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ImGuiTextIndexPtr self, ReadOnlySpan<byte> baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = baseValue)
			{
				appendNative(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ImGuiTextIndexPtr self, string baseValue, int oldSize, int newSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendNative(self, pStr0, oldSize, newSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ref ImGuiTextIndex self, ref byte baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					appendNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ref ImGuiTextIndex self, ReadOnlySpan<byte> baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				fixed (byte* pbaseValue = baseValue)
				{
					appendNative((ImGuiTextIndex*)pself, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void append(ref ImGuiTextIndex self, string baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				appendNative((ImGuiTextIndex*)pself, pStr0, oldSize, newSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStoragePair* ImLowerBoundNative(ImGuiStoragePair* inBegin, ImGuiStoragePair* inEnd, uint key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStoragePair*, ImGuiStoragePair*, uint, ImGuiStoragePair*>)funcTable[855])(inBegin, inEnd, key);
			#else
			return (ImGuiStoragePair*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint>)funcTable[855])((nint)inBegin, (nint)inEnd, key);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ImGuiStoragePairPtr inBegin, ImGuiStoragePairPtr inEnd, uint key)
		{
			ImGuiStoragePairPtr ret = ImLowerBoundNative(inBegin, inEnd, key);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ref ImGuiStoragePair inBegin, ImGuiStoragePairPtr inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinBegin = &inBegin)
			{
				ImGuiStoragePairPtr ret = ImLowerBoundNative((ImGuiStoragePair*)pinBegin, inEnd, key);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ImGuiStoragePairPtr inBegin, ref ImGuiStoragePair inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinEnd = &inEnd)
			{
				ImGuiStoragePairPtr ret = ImLowerBoundNative(inBegin, (ImGuiStoragePair*)pinEnd, key);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStoragePairPtr ImLowerBound(ref ImGuiStoragePair inBegin, ref ImGuiStoragePair inEnd, uint key)
		{
			fixed (ImGuiStoragePair* pinBegin = &inBegin)
			{
				fixed (ImGuiStoragePair* pinEnd = &inEnd)
				{
					ImGuiStoragePairPtr ret = ImLowerBoundNative((ImGuiStoragePair*)pinBegin, (ImGuiStoragePair*)pinEnd, key);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImDrawListSharedData* ImDrawListSharedDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawListSharedData*>)funcTable[856])();
			#else
			return (ImDrawListSharedData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[856])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawListSharedDataPtr ImDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = ImDrawListSharedDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImDrawListSharedData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawListSharedData*, void>)funcTable[857])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[857])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImDrawListSharedDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImDrawListSharedData self)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				DestroyNative((ImDrawListSharedData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCircleTessellationMaxErrorNative(ImDrawListSharedData* self, float maxError)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawListSharedData*, float, void>)funcTable[858])(self, maxError);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[858])((nint)self, maxError);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCircleTessellationMaxError(ImDrawListSharedDataPtr self, float maxError)
		{
			SetCircleTessellationMaxErrorNative(self, maxError);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCircleTessellationMaxError(ref ImDrawListSharedData self, float maxError)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				SetCircleTessellationMaxErrorNative((ImDrawListSharedData*)pself, maxError);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImDrawDataBuilder* ImDrawDataBuilderNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*>)funcTable[859])();
			#else
			return (ImDrawDataBuilder*)((delegate* unmanaged[Cdecl]<nint>)funcTable[859])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawDataBuilderPtr ImDrawDataBuilder()
		{
			ImDrawDataBuilderPtr ret = ImDrawDataBuilderNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImDrawDataBuilder* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*, void>)funcTable[860])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[860])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImDrawDataBuilderPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				DestroyNative((ImDrawDataBuilder*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetVarPtrNative(ImGuiStyleVarInfo* self, void* parent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVarInfo*, void*, void*>)funcTable[861])(self, parent);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[861])((nint)self, (nint)parent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetVarPtr(ImGuiStyleVarInfoPtr self, void* parent)
		{
			void* ret = GetVarPtrNative(self, parent);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetVarPtr(ref ImGuiStyleVarInfo self, void* parent)
		{
			fixed (ImGuiStyleVarInfo* pself = &self)
			{
				void* ret = GetVarPtrNative((ImGuiStyleVarInfo*)pself, parent);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, int, ImGuiStyleMod*>)funcTable[862])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, int, nint>)funcTable[862])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, int v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiStyleMod* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyleMod*, void>)funcTable[863])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[863])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiStyleModPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiStyleMod self)
		{
			fixed (ImGuiStyleMod* pself = &self)
			{
				DestroyNative((ImGuiStyleMod*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, float v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, ImGuiStyleMod*>)funcTable[864])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, nint>)funcTable[864])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, float v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, Vector2 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, ImGuiStyleMod*>)funcTable[865])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, nint>)funcTable[865])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, Vector2 v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiComboPreviewData* ImGuiComboPreviewDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiComboPreviewData*>)funcTable[866])();
			#else
			return (ImGuiComboPreviewData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[866])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiComboPreviewDataPtr ImGuiComboPreviewData()
		{
			ImGuiComboPreviewDataPtr ret = ImGuiComboPreviewDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiComboPreviewData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiComboPreviewData*, void>)funcTable[867])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[867])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiComboPreviewDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiComboPreviewData self)
		{
			fixed (ImGuiComboPreviewData* pself = &self)
			{
				DestroyNative((ImGuiComboPreviewData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiMenuColumns* ImGuiMenuColumnsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*>)funcTable[868])();
			#else
			return (ImGuiMenuColumns*)((delegate* unmanaged[Cdecl]<nint>)funcTable[868])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMenuColumnsPtr ImGuiMenuColumns()
		{
			ImGuiMenuColumnsPtr ret = ImGuiMenuColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiMenuColumns* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, void>)funcTable[869])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[869])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiMenuColumnsPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiMenuColumns self)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				DestroyNative((ImGuiMenuColumns*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateNative(ImGuiMenuColumns* self, float spacing, byte windowReappearing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, float, byte, void>)funcTable[870])(self, spacing, windowReappearing);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, byte, void>)funcTable[870])((nint)self, spacing, windowReappearing);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImGuiMenuColumnsPtr self, float spacing, bool windowReappearing)
		{
			UpdateNative(self, spacing, windowReappearing ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImGuiMenuColumns self, float spacing, bool windowReappearing)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				UpdateNative((ImGuiMenuColumns*)pself, spacing, windowReappearing ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DeclColumnsNative(ImGuiMenuColumns* self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, float, float, float, float, float>)funcTable[871])(self, wIcon, wLabel, wShortcut, wMark);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, float>)funcTable[871])((nint)self, wIcon, wLabel, wShortcut, wMark);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float DeclColumns(ImGuiMenuColumnsPtr self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			float ret = DeclColumnsNative(self, wIcon, wLabel, wShortcut, wMark);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float DeclColumns(ref ImGuiMenuColumns self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				float ret = DeclColumnsNative((ImGuiMenuColumns*)pself, wIcon, wLabel, wShortcut, wMark);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcNextTotalWidthNative(ImGuiMenuColumns* self, byte updateOffsets)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, byte, void>)funcTable[872])(self, updateOffsets);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[872])((nint)self, updateOffsets);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcNextTotalWidth(ImGuiMenuColumnsPtr self, bool updateOffsets)
		{
			CalcNextTotalWidthNative(self, updateOffsets ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcNextTotalWidth(ref ImGuiMenuColumns self, bool updateOffsets)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				CalcNextTotalWidthNative((ImGuiMenuColumns*)pself, updateOffsets ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiInputTextDeactivatedState* ImGuiInputTextDeactivatedStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextDeactivatedState*>)funcTable[873])();
			#else
			return (ImGuiInputTextDeactivatedState*)((delegate* unmanaged[Cdecl]<nint>)funcTable[873])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputTextDeactivatedStatePtr ImGuiInputTextDeactivatedState()
		{
			ImGuiInputTextDeactivatedStatePtr ret = ImGuiInputTextDeactivatedStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiInputTextDeactivatedState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextDeactivatedState*, void>)funcTable[874])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[874])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiInputTextDeactivatedStatePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				DestroyNative((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearFreeMemoryNative(ImGuiInputTextDeactivatedState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextDeactivatedState*, void>)funcTable[875])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[875])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ImGuiInputTextDeactivatedStatePtr self)
		{
			ClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ref ImGuiInputTextDeactivatedState self)
		{
			fixed (ImGuiInputTextDeactivatedState* pself = &self)
			{
				ClearFreeMemoryNative((ImGuiInputTextDeactivatedState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiInputTextState* ImGuiInputTextStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*>)funcTable[876])();
			#else
			return (ImGuiInputTextState*)((delegate* unmanaged[Cdecl]<nint>)funcTable[876])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputTextStatePtr ImGuiInputTextState()
		{
			ImGuiInputTextStatePtr ret = ImGuiInputTextStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[877])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[877])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiInputTextStatePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				DestroyNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTextNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[878])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[878])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearText(ImGuiInputTextStatePtr self)
		{
			ClearTextNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearText(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearTextNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearFreeMemoryNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[879])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[879])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ImGuiInputTextStatePtr self)
		{
			ClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearFreeMemoryNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnKeyPressedNative(ImGuiInputTextState* self, int key)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int, void>)funcTable[880])(self, key);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[880])((nint)self, key);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OnKeyPressed(ImGuiInputTextStatePtr self, int key)
		{
			OnKeyPressedNative(self, key);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OnKeyPressed(ref ImGuiInputTextState self, int key)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				OnKeyPressedNative((ImGuiInputTextState*)pself, key);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnCharPressedNative(ImGuiInputTextState* self, uint c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, uint, void>)funcTable[881])(self, c);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[881])((nint)self, c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OnCharPressed(ImGuiInputTextStatePtr self, uint c)
		{
			OnCharPressedNative(self, c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OnCharPressed(ref ImGuiInputTextState self, uint c)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				OnCharPressedNative((ImGuiInputTextState*)pself, c);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CursorAnimResetNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[882])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[882])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorAnimReset(ImGuiInputTextStatePtr self)
		{
			CursorAnimResetNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorAnimReset(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				CursorAnimResetNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CursorClampNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[883])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[883])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorClamp(ImGuiInputTextStatePtr self)
		{
			CursorClampNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorClamp(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				CursorClampNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, byte>)funcTable[884])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[884])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasSelection(ImGuiInputTextStatePtr self)
		{
			byte ret = HasSelectionNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				byte ret = HasSelectionNative((ImGuiInputTextState*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[885])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[885])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearSelection(ImGuiInputTextStatePtr self)
		{
			ClearSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearSelectionNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCursorPosNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)funcTable[886])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[886])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetCursorPos(ImGuiInputTextStatePtr self)
		{
			int ret = GetCursorPosNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetCursorPos(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetCursorPosNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSelectionStartNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)funcTable[887])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[887])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionStart(ImGuiInputTextStatePtr self)
		{
			int ret = GetSelectionStartNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionStart(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetSelectionStartNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSelectionEndNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)funcTable[888])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[888])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionEnd(ImGuiInputTextStatePtr self)
		{
			int ret = GetSelectionEndNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetSelectionEndNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SelectAllNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[889])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[889])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SelectAll(ImGuiInputTextStatePtr self)
		{
			SelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				SelectAllNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReloadUserBufAndSelectAllNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[890])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[890])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndSelectAll(ImGuiInputTextStatePtr self)
		{
			ReloadUserBufAndSelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndSelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ReloadUserBufAndSelectAllNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReloadUserBufAndKeepSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[891])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[891])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndKeepSelection(ImGuiInputTextStatePtr self)
		{
			ReloadUserBufAndKeepSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndKeepSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ReloadUserBufAndKeepSelectionNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReloadUserBufAndMoveToEndNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[892])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[892])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndMoveToEnd(ImGuiInputTextStatePtr self)
		{
			ReloadUserBufAndMoveToEndNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReloadUserBufAndMoveToEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ReloadUserBufAndMoveToEndNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiNextWindowData* ImGuiNextWindowDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*>)funcTable[893])();
			#else
			return (ImGuiNextWindowData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[893])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNextWindowDataPtr ImGuiNextWindowData()
		{
			ImGuiNextWindowDataPtr ret = ImGuiNextWindowDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiNextWindowData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*, void>)funcTable[894])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[894])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiNextWindowDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				DestroyNative((ImGuiNextWindowData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearFlagsNative(ImGuiNextWindowData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*, void>)funcTable[895])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[895])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ImGuiNextWindowDataPtr self)
		{
			ClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ClearFlagsNative((ImGuiNextWindowData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiNextItemData* ImGuiNextItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNextItemData*>)funcTable[896])();
			#else
			return (ImGuiNextItemData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[896])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNextItemDataPtr ImGuiNextItemData()
		{
			ImGuiNextItemDataPtr ret = ImGuiNextItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiNextItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextItemData*, void>)funcTable[897])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[897])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiNextItemDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				DestroyNative((ImGuiNextItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearFlagsNative(ImGuiNextItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextItemData*, void>)funcTable[898])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[898])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ImGuiNextItemDataPtr self)
		{
			ClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ClearFlagsNative((ImGuiNextItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiLastItemData* ImGuiLastItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiLastItemData*>)funcTable[899])();
			#else
			return (ImGuiLastItemData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[899])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiLastItemDataPtr ImGuiLastItemData()
		{
			ImGuiLastItemDataPtr ret = ImGuiLastItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiLastItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiLastItemData*, void>)funcTable[900])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[900])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiLastItemDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiLastItemData self)
		{
			fixed (ImGuiLastItemData* pself = &self)
			{
				DestroyNative((ImGuiLastItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiErrorRecoveryState* ImGuiErrorRecoveryStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiErrorRecoveryState*>)funcTable[901])();
			#else
			return (ImGuiErrorRecoveryState*)((delegate* unmanaged[Cdecl]<nint>)funcTable[901])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiErrorRecoveryStatePtr ImGuiErrorRecoveryState()
		{
			ImGuiErrorRecoveryStatePtr ret = ImGuiErrorRecoveryStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiErrorRecoveryState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiErrorRecoveryState*, void>)funcTable[902])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[902])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiErrorRecoveryStatePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiErrorRecoveryState self)
		{
			fixed (ImGuiErrorRecoveryState* pself = &self)
			{
				DestroyNative((ImGuiErrorRecoveryState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPtrOrIndex* ImGuiPtrOrIndexNative(void* ptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ImGuiPtrOrIndex*>)funcTable[903])(ptr);
			#else
			return (ImGuiPtrOrIndex*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[903])((nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndex(void* ptr)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPtrOrIndexNative(ptr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiPtrOrIndex* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiPtrOrIndex*, void>)funcTable[904])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[904])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiPtrOrIndexPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiPtrOrIndex self)
		{
			fixed (ImGuiPtrOrIndex* pself = &self)
			{
				DestroyNative((ImGuiPtrOrIndex*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPtrOrIndex* ImGuiPtrOrIndexNative(int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiPtrOrIndex*>)funcTable[905])(index);
			#else
			return (ImGuiPtrOrIndex*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[905])(index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndex(int index)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPtrOrIndexNative(index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPopupData* ImGuiPopupDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiPopupData*>)funcTable[906])();
			#else
			return (ImGuiPopupData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[906])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPopupDataPtr ImGuiPopupData()
		{
			ImGuiPopupDataPtr ret = ImGuiPopupDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiPopupData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiPopupData*, void>)funcTable[907])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[907])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiPopupDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiPopupData self)
		{
			fixed (ImGuiPopupData* pself = &self)
			{
				DestroyNative((ImGuiPopupData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiInputEvent* ImGuiInputEventNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputEvent*>)funcTable[908])();
			#else
			return (ImGuiInputEvent*)((delegate* unmanaged[Cdecl]<nint>)funcTable[908])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputEventPtr ImGuiInputEvent()
		{
			ImGuiInputEventPtr ret = ImGuiInputEventNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiInputEvent* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputEvent*, void>)funcTable[909])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[909])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiInputEventPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiInputEvent self)
		{
			fixed (ImGuiInputEvent* pself = &self)
			{
				DestroyNative((ImGuiInputEvent*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiKeyRoutingData* ImGuiKeyRoutingDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingData*>)funcTable[910])();
			#else
			return (ImGuiKeyRoutingData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[910])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyRoutingDataPtr ImGuiKeyRoutingData()
		{
			ImGuiKeyRoutingDataPtr ret = ImGuiKeyRoutingDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiKeyRoutingData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingData*, void>)funcTable[911])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[911])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiKeyRoutingDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiKeyRoutingData self)
		{
			fixed (ImGuiKeyRoutingData* pself = &self)
			{
				DestroyNative((ImGuiKeyRoutingData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiKeyRoutingTable* ImGuiKeyRoutingTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingTable*>)funcTable[912])();
			#else
			return (ImGuiKeyRoutingTable*)((delegate* unmanaged[Cdecl]<nint>)funcTable[912])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyRoutingTablePtr ImGuiKeyRoutingTable()
		{
			ImGuiKeyRoutingTablePtr ret = ImGuiKeyRoutingTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiKeyRoutingTable* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingTable*, void>)funcTable[913])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[913])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiKeyRoutingTablePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				DestroyNative((ImGuiKeyRoutingTable*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(ImGuiKeyRoutingTable* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyRoutingTable*, void>)funcTable[914])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[914])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImGuiKeyRoutingTablePtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImGuiKeyRoutingTable self)
		{
			fixed (ImGuiKeyRoutingTable* pself = &self)
			{
				ClearNative((ImGuiKeyRoutingTable*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiKeyOwnerData* ImGuiKeyOwnerDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKeyOwnerData*>)funcTable[915])();
			#else
			return (ImGuiKeyOwnerData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[915])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiKeyOwnerDataPtr ImGuiKeyOwnerData()
		{
			ImGuiKeyOwnerDataPtr ret = ImGuiKeyOwnerDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiKeyOwnerData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKeyOwnerData*, void>)funcTable[916])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[916])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiKeyOwnerDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiKeyOwnerData self)
		{
			fixed (ImGuiKeyOwnerData* pself = &self)
			{
				DestroyNative((ImGuiKeyOwnerData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiListClipperRange FromIndicesNative(int min, int max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, ImGuiListClipperRange>)funcTable[917])(min, max);
			#else
			return (ImGuiListClipperRange)((delegate* unmanaged[Cdecl]<int, int, ImGuiListClipperRange>)funcTable[917])(min, max);
			#endif
		}
	}
}
